//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
module rec WGPU.Native

open System
open System.Runtime.InteropServices
open Microsoft.FSharp.Core


/// <summary>
/// Handle to a physical graphics and/or compute device.
/// <br/>
/// Adapters can be used to open a connection to the corresponding Device on the host system by using Adapter::request_device.
/// <br/>
/// Does not have to be kept alive.
/// <br/>
/// </summary>
///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type Adapter =
    struct
        val handle : AdapterImpl
        new(ptr) = { handle = ptr }
    end
    /// <summary>
    /// List all features that are supported with this adapter.
    /// </summary>
    member this.EnumerateFeatures(features: FeatureName nativeptr) = wgpuAdapterEnumerateFeatures(this, features)
    /// <summary>
    /// List the “best” limits that are supported by this adapter.
    /// <br/>
    /// Limits must be explicitly requested in Adapter.RequestDevice to set the values that you are allowed to use.
    /// <br/>
    /// </summary>
    member this.GetLimits(limits: SupportedLimits nativeptr) = wgpuAdapterGetLimits(this, limits)
    /// <summary>
    /// Get info about the adapter itself.
    /// </summary>
    member this.GetProperties(properties: AdapterProperties byref) = wgpuAdapterGetProperties(this, &properties)
    /// <summary>
    /// Returns whether this adapter has the requested feature.
    /// </summary>
    member this.HasFeature(feature: FeatureName) = wgpuAdapterHasFeature(this, feature)
    /// <summary>
    /// Requests a connection to a physical device, creating a logical device.
    /// </summary>
    member this.RequestDevice(descriptor: DeviceDescriptor byref, callback: RequestDeviceCallback, userdata: nativeint) = wgpuAdapterRequestDevice(this, &descriptor, callback, userdata)
    override this.ToString() = $"%X{this.handle}"
and AdapterImpl = nativeint

/// <summary>
/// Handle to a binding group.
/// <br/>
/// A BindGroup represents the set of resources bound to the bindings described by a BindGroupLayout. It can be created with Device.CreateBindGroup. A BindGroup can be bound to a particular RenderPass with RenderPass.SetBindGroup, or to a ComputePass with ComputePass.SetBindGroup.
/// <br/>
/// </summary>
///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type BindGroup =
    struct
        val handle : BindGroupImpl
        new(ptr) = { handle = ptr }
    end
    /// <summary>
    /// Executes the destructor for this type.
    /// </summary>
    member this.Drop() = wgpuBindGroupDrop(this)
    override this.ToString() = $"%X{this.handle}"
and BindGroupImpl = nativeint

/// <summary>
/// Handle to a binding group layout.
/// <br/>
/// A BindGroupLayout is a handle to the GPU-side layout of a binding group. It can be used to create a BindGroupDescriptor object, which in turn can be used to create a BindGroup object with Device.CreateBindGroup. A series of BindGroupLayouts can also be used to create a PipelineLayoutDescriptor, which can be used to create a PipelineLayout.
/// <br/>
/// </summary>
///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type BindGroupLayout =
    struct
        val handle : BindGroupLayoutImpl
        new(ptr) = { handle = ptr }
    end
    /// <summary>
    /// Executes the destructor for this type.
    /// </summary>
    member this.Drop() = wgpuBindGroupLayoutDrop(this)
    override this.ToString() = $"%X{this.handle}"
and BindGroupLayoutImpl = nativeint

/// <summary>
/// Handle to a GPU-accessible buffer.
/// <br/>
/// Created with Device.CreateBuffer or DeviceExt.CreateBufferInit.
/// <br/>
/// </summary>
///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type Buffer =
    struct
        val handle : BufferImpl
        new(ptr) = { handle = ptr }
    end
    /// <summary>
    /// Destroy the associated native resources as soon as possible.
    /// </summary>
    member this.Destroy() = wgpuBufferDestroy(this)
    member this.GetConstMappedRange(offset: uint64, size: uint64) = wgpuBufferGetConstMappedRange(this, offset, size)
    member this.GetMappedRange(offset: uint64, size: uint64) = wgpuBufferGetMappedRange(this, offset, size)
    member this.MapAsync(mode: MapMode, offset: uint64, size: uint64, callback: BufferMapCallback, userdata: nativeint) = wgpuBufferMapAsync(this, mode, offset, size, callback, userdata)
    /// <summary>
    /// Flushes any pending write operations and unmaps the buffer from host memory.
    /// </summary>
    member this.Unmap() = wgpuBufferUnmap(this)
    /// <summary>
    /// Executes the destructor for this type.
    /// </summary>
    member this.Drop() = wgpuBufferDrop(this)
    override this.ToString() = $"%X{this.handle}"
and BufferImpl = nativeint

/// <summary>
/// Handle to a command buffer on the GPU.
/// <br/>
/// A CommandBuffer represents a complete sequence of commands that may be submitted to a command queue with Queue.Submit. A CommandBuffer is obtained by recording a series of commands to a CommandEncoder and then calling CommandEncoder.Finish.
/// </summary>
///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type CommandBuffer =
    struct
        val handle : CommandBufferImpl
        new(ptr) = { handle = ptr }
    end
    /// <summary>
    /// Executes the destructor for this type.
    /// </summary>
    member this.Drop() = wgpuCommandBufferDrop(this)
    override this.ToString() = $"%X{this.handle}"
and CommandBufferImpl = nativeint

/// <summary>
/// Encodes a series of GPU operations.
/// <br/>
/// A command encoder can record RenderPasses, ComputePasses, and transfer operations between driver-managed resources like Buffers and Textures.
/// <br/>
/// When finished recording, call CommandEncoder.Finish to obtain a CommandBuffer which may be submitted for execution.
/// <br/>
/// </summary>
///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type CommandEncoder =
    struct
        val handle : CommandEncoderImpl
        new(ptr) = { handle = ptr }
    end
    /// <summary>
    /// Begins recording of a compute pass.
    /// <br/>
    /// This function returns a ComputePass object which records a single compute pass.
    /// </summary>
    member this.BeginComputePass(descriptor: ComputePassDescriptor byref) = wgpuCommandEncoderBeginComputePass(this, &descriptor)
    /// <summary>
    /// Begins recording of a render pass.
    /// <br/>
    /// This function returns a RenderPass object which records a single render pass.
    /// </summary>
    member this.BeginRenderPass(descriptor: RenderPassDescriptor byref) = wgpuCommandEncoderBeginRenderPass(this, &descriptor)
    member this.ClearBuffer(buffer: Buffer, offset: uint64, size: uint64) = wgpuCommandEncoderClearBuffer(this, buffer, offset, size)
    member this.CopyBufferToBuffer(source: Buffer, sourceOffset: uint64, destination: Buffer, destinationOffset: uint64, size: uint64) = wgpuCommandEncoderCopyBufferToBuffer(this, source, sourceOffset, destination, destinationOffset, size)
    member this.CopyBufferToTexture(source: ImageCopyBuffer nativeptr, destination: ImageCopyTexture nativeptr, copySize: Extent3D nativeptr) = wgpuCommandEncoderCopyBufferToTexture(this, source, destination, copySize)
    member this.CopyTextureToBuffer(source: ImageCopyTexture nativeptr, destination: ImageCopyBuffer nativeptr, copySize: Extent3D nativeptr) = wgpuCommandEncoderCopyTextureToBuffer(this, source, destination, copySize)
    member this.CopyTextureToTexture(source: ImageCopyTexture nativeptr, destination: ImageCopyTexture nativeptr, copySize: Extent3D nativeptr) = wgpuCommandEncoderCopyTextureToTexture(this, source, destination, copySize)
    /// <summary>
    /// Finishes recording and returns a CommandBuffer that can be submitted for execution.
    /// </summary>
    member this.Finish(descriptor: CommandBufferDescriptor byref) = wgpuCommandEncoderFinish(this, &descriptor)
    member this.InsertDebugMarker(markerLabel: string) = wgpuCommandEncoderInsertDebugMarker(this, markerLabel)
    member this.PopDebugGroup() = wgpuCommandEncoderPopDebugGroup(this)
    member this.PushDebugGroup(groupLabel: string) = wgpuCommandEncoderPushDebugGroup(this, groupLabel)
    member this.ResolveQuerySet(querySet: QuerySet, firstQuery: uint32, queryCount: uint32, destination: Buffer, destinationOffset: uint64) = wgpuCommandEncoderResolveQuerySet(this, querySet, firstQuery, queryCount, destination, destinationOffset)
    member this.WriteTimestamp(querySet: QuerySet, queryIndex: uint32) = wgpuCommandEncoderWriteTimestamp(this, querySet, queryIndex)
    /// <summary>
    /// Executes the destructor for this type.
    /// </summary>
    member this.Drop() = wgpuCommandEncoderDrop(this)
    override this.ToString() = $"%X{this.handle}"
and CommandEncoderImpl = nativeint

/// <summary>
/// In-progress recording of a compute pass.
/// </summary>
///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type ComputePassEncoder =
    struct
        val handle : ComputePassEncoderImpl
        new(ptr) = { handle = ptr }
    end
    /// <summary>
    /// Start a pipeline statistics query on this render pass. It can be ended with end_pipeline_statistics_query. Pipeline statistics queries may not be nested.
    /// </summary>
    member this.BeginPipelineStatisticsQuery(querySet: QuerySet, queryIndex: uint32) = wgpuComputePassEncoderBeginPipelineStatisticsQuery(this, querySet, queryIndex)
    /// <summary>
    /// Dispatches compute work operations.
    /// <br/>
    /// x, y and z denote the number of work groups to dispatch in each dimension.
    /// </summary>
    member this.Dispatch(workgroupCountX: uint32, workgroupCountY: uint32, workgroupCountZ: uint32) = wgpuComputePassEncoderDispatch(this, workgroupCountX, workgroupCountY, workgroupCountZ)
    /// <summary>
    /// Dispatches compute work operations, based on the contents of the indirect_buffer.
    /// </summary>
    member this.DispatchIndirect(indirectBuffer: Buffer, indirectOffset: uint64) = wgpuComputePassEncoderDispatchIndirect(this, indirectBuffer, indirectOffset)
    member this.End() = wgpuComputePassEncoderEnd(this)
    /// <summary>
    /// End the pipeline statistics query on this render pass. It can be started with begin_pipeline_statistics_query. Pipeline statistics queries may not be nested.
    /// </summary>
    member this.EndPipelineStatisticsQuery() = wgpuComputePassEncoderEndPipelineStatisticsQuery(this)
    member this.InsertDebugMarker(markerLabel: string) = wgpuComputePassEncoderInsertDebugMarker(this, markerLabel)
    member this.PopDebugGroup() = wgpuComputePassEncoderPopDebugGroup(this)
    member this.PushDebugGroup(groupLabel: string) = wgpuComputePassEncoderPushDebugGroup(this, groupLabel)
    /// <summary>
    /// Sets the active bind group for a given bind group index. The bind group layout in the active pipeline when the dispatch() function is called must match the layout of this bind group.
    /// <br/>
    /// If the bind group have dynamic offsets, provide them in the binding order. These offsets have to be aligned to Limits.minUniformBufferOffsetAlignment or Limits.minStorageBufferOffsetAlignment appropriately.
    /// <br/>
    /// </summary>
    member this.SetBindGroup(groupIndex: uint32, group: BindGroup, dynamicOffsetCount: uint32, dynamicOffsets: uint32 nativeptr) = wgpuComputePassEncoderSetBindGroup(this, groupIndex, group, dynamicOffsetCount, dynamicOffsets)
    /// <summary>
    /// Sets the active compute pipeline.
    /// </summary>
    member this.SetPipeline(pipeline: ComputePipeline) = wgpuComputePassEncoderSetPipeline(this, pipeline)
    override this.ToString() = $"%X{this.handle}"
and ComputePassEncoderImpl = nativeint

/// <summary>
/// Handle to a compute pipeline.
/// <br/>
/// A ComputePipeline object represents a compute pipeline and its single shader stage. A ComputePipeline may be created with Device.CreatePipeline.
/// <br/>
/// </summary>
///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type ComputePipeline =
    struct
        val handle : ComputePipelineImpl
        new(ptr) = { handle = ptr }
    end
    /// <summary>
    /// Get an object representing the bind group layout at a given index.
    /// </summary>
    member this.GetBindGroupLayout(groupIndex: uint32) = wgpuComputePipelineGetBindGroupLayout(this, groupIndex)
    member this.SetLabel(label: string) = wgpuComputePipelineSetLabel(this, label)
    /// <summary>
    /// Executes the destructor for this type.
    /// </summary>
    member this.Drop() = wgpuComputePipelineDrop(this)
    override this.ToString() = $"%X{this.handle}"
and ComputePipelineImpl = nativeint

/// <summary>
/// Open connection to a graphics and/or compute device.
/// <br/>
/// Responsible for the creation of most rendering and compute resources. These are then used in commands, which are submitted to a Queue.
/// <br/>
/// A device may be requested from an adapter with Adapter.RequestDevice.
/// </summary>
///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type Device =
    struct
        val handle : DeviceImpl
        new(ptr) = { handle = ptr }
    end
    /// <summary>
    /// Creates a new BindGroup.
    /// </summary>
    member this.CreateBindGroup(descriptor: BindGroupDescriptor byref) = wgpuDeviceCreateBindGroup(this, &descriptor)
    /// <summary>
    /// Creates a new BindGroupLayout.
    /// </summary>
    member this.CreateBindGroupLayout(descriptor: BindGroupLayoutDescriptor byref) = wgpuDeviceCreateBindGroupLayout(this, &descriptor)
    /// <summary>
    /// Creates a Buffer.
    /// </summary>
    member this.CreateBuffer(descriptor: BufferDescriptor byref) = wgpuDeviceCreateBuffer(this, &descriptor)
    /// <summary>
    /// Creates an empty CommandEncoder.
    /// </summary>
    member this.CreateCommandEncoder(descriptor: CommandEncoderDescriptor byref) = wgpuDeviceCreateCommandEncoder(this, &descriptor)
    /// <summary>
    /// Creates a ComputePipeline.
    /// </summary>
    member this.CreateComputePipeline(descriptor: ComputePipelineDescriptor byref) = wgpuDeviceCreateComputePipeline(this, &descriptor)
    /// <summary>
    /// Creates a ComputePipeline asynchronously.
    /// </summary>
    member this.CreateComputePipelineAsync(descriptor: ComputePipelineDescriptor byref, callback: CreateComputePipelineAsyncCallback, userdata: nativeint) = wgpuDeviceCreateComputePipelineAsync(this, &descriptor, callback, userdata)
    /// <summary>
    /// Creates a PipelineLayout.
    /// </summary>
    member this.CreatePipelineLayout(descriptor: PipelineLayoutDescriptor byref) = wgpuDeviceCreatePipelineLayout(this, &descriptor)
    /// <summary>
    /// Creates a QuerySet.
    /// </summary>
    member this.CreateQuerySet(descriptor: QuerySetDescriptor byref) = wgpuDeviceCreateQuerySet(this, &descriptor)
    /// <summary>
    /// Creates an empty RenderBundleEncoder.
    /// </summary>
    member this.CreateRenderBundleEncoder(descriptor: RenderBundleEncoderDescriptor byref) = wgpuDeviceCreateRenderBundleEncoder(this, &descriptor)
    /// <summary>
    /// Creates a RenderPipeline.
    /// </summary>
    member this.CreateRenderPipeline(descriptor: RenderPipelineDescriptor byref) = wgpuDeviceCreateRenderPipeline(this, &descriptor)
    /// <summary>
    /// Creates a RenderPipeline asynchronously.
    /// </summary>
    member this.CreateRenderPipelineAsync(descriptor: RenderPipelineDescriptor byref, callback: CreateRenderPipelineAsyncCallback, userdata: nativeint) = wgpuDeviceCreateRenderPipelineAsync(this, &descriptor, callback, userdata)
    /// <summary>
    /// Creates a new Sampler.
    /// </summary>
    member this.CreateSampler(descriptor: SamplerDescriptor byref) = wgpuDeviceCreateSampler(this, &descriptor)
    /// <summary>
    /// Creates a shader module from either SPIR-V or WGSL source code.
    /// </summary>
    member this.CreateShaderModule(descriptor: ShaderModuleDescriptor byref) = wgpuDeviceCreateShaderModule(this, &descriptor)
    /// <summary>
    /// Creates a new SwapChain.
    /// </summary>
    member this.CreateSwapChain(surface: Surface, descriptor: SwapChainDescriptor byref) = wgpuDeviceCreateSwapChain(this, surface, &descriptor)
    /// <summary>
    /// Creates a new Texture.
    /// </summary>
    member this.CreateTexture(descriptor: TextureDescriptor byref) = wgpuDeviceCreateTexture(this, &descriptor)
    /// <summary>
    /// Destroy the associated native resources as soon as possible.
    /// </summary>
    member this.Destroy() = wgpuDeviceDestroy(this)
    /// <summary>
    /// List all features that may be used with this device.
    /// <br/>
    /// Functions may panic if you use unsupported features.
    /// </summary>
    member this.EnumerateFeatures(features: FeatureName nativeptr) = wgpuDeviceEnumerateFeatures(this, features)
    /// <summary>
    /// List all limits that were requested of this device.
    /// <br/>
    /// If any of these limits are exceeded, functions may panic.
    /// </summary>
    member this.GetLimits(limits: SupportedLimits nativeptr) = wgpuDeviceGetLimits(this, limits)
    /// <summary>
    /// Retrieves the queue for the device.
    /// </summary>
    member this.GetQueue() = wgpuDeviceGetQueue(this)
    /// <summary>
    /// Returns whether this adapter has the requested feature.
    /// </summary>
    member this.HasFeature(feature: FeatureName) = wgpuDeviceHasFeature(this, feature)
    member this.PopErrorScope(callback: ErrorCallback, userdata: nativeint) = wgpuDevicePopErrorScope(this, callback, userdata)
    member this.PushErrorScope(filter: ErrorFilter) = wgpuDevicePushErrorScope(this, filter)
    /// <summary>
    /// Sets a callback to be executed if device is lost.
    /// </summary>
    member this.SetDeviceLostCallback(callback: DeviceLostCallback, userdata: nativeint) = wgpuDeviceSetDeviceLostCallback(this, callback, userdata)
    /// <summary>
    /// Sets a callback to be executed if an error occurs.
    /// </summary>
    member this.SetUncapturedErrorCallback(callback: ErrorCallback, userdata: nativeint) = wgpuDeviceSetUncapturedErrorCallback(this, callback, userdata)
    /// <summary>
    /// Check for resource cleanups and mapping callbacks.
    /// <br/>
    /// no-op on the web, device is automatically polled.
    /// </summary>
    member this.Poll(force_wait: bool) = wgpuDevicePoll(this, force_wait)
    /// <summary>
    /// Executes the destructor for this type.
    /// </summary>
    member this.Drop() = wgpuDeviceDrop(this)
    override this.ToString() = $"%X{this.handle}"
and DeviceImpl = nativeint

/// <summary>
/// Context for all other wgpu objects. Instance of wgpu.
/// <br/>
/// This is the first thing you create when using wgpu. Its primary use is to create Adapters and Surfaces.
/// <br/>
/// Does not have to be kept alive.
/// </summary>
///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type Instance =
    struct
        val handle : InstanceImpl
        new(ptr) = { handle = ptr }
    end
    /// <summary>
    /// Creates a surface from a raw window handle.
    /// </summary>
    member this.CreateSurface(descriptor: SurfaceDescriptor byref) = wgpuInstanceCreateSurface(this, &descriptor)
    member this.ProcessEvents() = wgpuInstanceProcessEvents(this)
    /// <summary>
    /// Retrieves an Adapter which matches the given RequestAdapterOptions.
    /// </summary>
    member this.RequestAdapter(options: RequestAdapterOptions nativeptr, callback: RequestAdapterCallback, userdata: nativeint) = wgpuInstanceRequestAdapter(this, options, callback, userdata)
    override this.ToString() = $"%X{this.handle}"
and InstanceImpl = nativeint

/// <summary>
/// Handle to a pipeline layout.
/// <br/>
/// A PipelineLayout object describes the available binding groups of a pipeline.
/// </summary>
///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type PipelineLayout =
    struct
        val handle : PipelineLayoutImpl
        new(ptr) = { handle = ptr }
    end
    /// <summary>
    /// Executes the destructor for this type.
    /// </summary>
    member this.Drop() = wgpuPipelineLayoutDrop(this)
    override this.ToString() = $"%X{this.handle}"
and PipelineLayoutImpl = nativeint

/// <summary>
/// Handle to a query set.
/// </summary>
///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type QuerySet =
    struct
        val handle : QuerySetImpl
        new(ptr) = { handle = ptr }
    end
    /// <summary>
    /// Destroy the associated native resources as soon as possible.
    /// </summary>
    member this.Destroy() = wgpuQuerySetDestroy(this)
    /// <summary>
    /// Executes the destructor for this type.
    /// </summary>
    member this.Drop() = wgpuQuerySetDrop(this)
    override this.ToString() = $"%X{this.handle}"
and QuerySetImpl = nativeint

/// <summary>
/// Handle to a command queue on a device.
/// <br/>
/// A Queue executes recorded CommandBuffer objects and provides convenience methods for writing to buffers and textures.
/// </summary>
///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type Queue =
    struct
        val handle : QueueImpl
        new(ptr) = { handle = ptr }
    end
    /// <summary>
    /// Registers a callback that will be executed once all the work submitted by this point is done processing on GPU.
    /// </summary>
    member this.OnSubmittedWorkDone(callback: QueueWorkDoneCallback, userdata: nativeint) = wgpuQueueOnSubmittedWorkDone(this, callback, userdata)
    /// <summary>
    /// Submits a series of finished command buffers for execution.
    /// </summary>
    member this.Submit(commandCount: uint32, commands: CommandBuffer nativeptr) = wgpuQueueSubmit(this, commandCount, commands)
    /// <summary>
    /// Schedule a data write into buffer starting at offset.
    /// <br/>
    /// This method is intended to have low performance costs. As such, the write is not immediately submitted, and instead enqueued internally to happen at the start of the next submit() call.
    /// <br/>
    /// This method fails if data overruns the size of buffer starting at offset.
    /// </summary>
    member this.WriteBuffer(buffer: Buffer, bufferOffset: uint64, data: nativeint, size: uint64) = wgpuQueueWriteBuffer(this, buffer, bufferOffset, data, size)
    /// <summary>
    /// Schedule a data write into texture.
    /// <br/>
    /// This method is intended to have low performance costs. As such, the write is not immediately submitted, and instead enqueued internally to happen at the start of the next submit() call.
    /// <br/>
    /// This method fails if data overruns the size of fragment of texture specified with size.
    /// <br/>
    /// </summary>
    member this.WriteTexture(destination: ImageCopyTexture nativeptr, data: nativeint, dataSize: uint64, dataLayout: TextureDataLayout nativeptr, writeSize: Extent3D nativeptr) = wgpuQueueWriteTexture(this, destination, data, dataSize, dataLayout, writeSize)
    override this.ToString() = $"%X{this.handle}"
and QueueImpl = nativeint

/// <summary>
/// Pre-prepared reusable bundle of GPU operations.
/// <br/>
/// It only supports a handful of render commands, but it makes them reusable. RenderBundles can be executed onto a CommandEncoder using RenderPass::execute_bundles.
/// <br/>
/// Executing a RenderBundle is often more efficient then issuing the underlying commands manually.
/// </summary>
///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type RenderBundle =
    struct
        val handle : RenderBundleImpl
        new(ptr) = { handle = ptr }
    end
    /// <summary>
    /// Executes the destructor for this type.
    /// </summary>
    member this.Drop() = wgpuRenderBundleDrop(this)
    override this.ToString() = $"%X{this.handle}"
and RenderBundleImpl = nativeint

/// <summary>
/// Encodes a series of GPU operations into a reusable “render bundle”.
/// <br/>
/// It only supports a handful of render commands, but it makes them reusable. RenderBundles can be executed onto a CommandEncoder using RenderPass.ExecuteBundles.
/// <br/>
/// Executing a RenderBundle is often more efficient then issuing the underlying commands manually.
/// </summary>
///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type RenderBundleEncoder =
    struct
        val handle : RenderBundleEncoderImpl
        new(ptr) = { handle = ptr }
    end
    /// <summary>
    /// Draws primitives from the active vertex buffer(s).
    /// <br/>
    /// The active vertex buffers can be set with RenderBundleEncoder.SetVertexBuffer.
    /// </summary>
    member this.Draw(vertexCount: uint32, instanceCount: uint32, firstVertex: uint32, firstInstance: uint32) = wgpuRenderBundleEncoderDraw(this, vertexCount, instanceCount, firstVertex, firstInstance)
    /// <summary>
    /// Draws indexed primitives using the active index buffer and the active vertex buffers.
    /// <br/>
    /// The active index buffer can be set with RenderBundleEncoder.SetIndexBuffer, while the active vertex buffers can be set with RenderBundleEncoder.SetVertexBuffer.
    /// <br/>
    /// </summary>
    member this.DrawIndexed(indexCount: uint32, instanceCount: uint32, firstIndex: uint32, baseVertex: int32, firstInstance: uint32) = wgpuRenderBundleEncoderDrawIndexed(this, indexCount, instanceCount, firstIndex, baseVertex, firstInstance)
    /// <summary>
    /// Draws indexed primitives using the active index buffer and the active vertex buffers, based on the contents of the indirectBuffer.
    /// <br/>
    /// The active index buffer can be set with RenderBundleEncoder.SetIndexBuffer, while the active vertex buffers can be set with RenderBundleEncoder.SetVertexBuffer.
    /// </summary>
    member this.DrawIndexedIndirect(indirectBuffer: Buffer, indirectOffset: uint64) = wgpuRenderBundleEncoderDrawIndexedIndirect(this, indirectBuffer, indirectOffset)
    /// <summary>
    /// Draws primitives from the active vertex buffer(s) based on the contents of the indirectBuffer.
    /// <br/>
    /// The active vertex buffers can be set with RenderBundleEncoder.SetVertexBuffer.
    /// </summary>
    member this.DrawIndirect(indirectBuffer: Buffer, indirectOffset: uint64) = wgpuRenderBundleEncoderDrawIndirect(this, indirectBuffer, indirectOffset)
    /// <summary>
    /// Finishes recording and returns a RenderBundle that can be executed in other render passes.
    /// </summary>
    member this.Finish(descriptor: RenderBundleDescriptor byref) = wgpuRenderBundleEncoderFinish(this, &descriptor)
    member this.InsertDebugMarker(markerLabel: string) = wgpuRenderBundleEncoderInsertDebugMarker(this, markerLabel)
    member this.PopDebugGroup() = wgpuRenderBundleEncoderPopDebugGroup(this)
    member this.PushDebugGroup(groupLabel: string) = wgpuRenderBundleEncoderPushDebugGroup(this, groupLabel)
    /// <summary>
    /// Sets the active bind group for a given bind group index. The bind group layout in the active pipeline when any draw() function is called must match the layout of this bind group.
    /// <br/>
    /// If the bind group have dynamic offsets, provide them in the binding order.
    /// </summary>
    member this.SetBindGroup(groupIndex: uint32, group: BindGroup, dynamicOffsetCount: uint32, dynamicOffsets: uint32 nativeptr) = wgpuRenderBundleEncoderSetBindGroup(this, groupIndex, group, dynamicOffsetCount, dynamicOffsets)
    /// <summary>
    /// Sets the active index buffer.
    /// <br/>
    /// Subsequent calls to DrawIndexed on this RenderBundleEncoder will use buffer as the source index buffer.
    /// <br/>
    /// </summary>
    member this.SetIndexBuffer(buffer: Buffer, format: IndexFormat, offset: uint64, size: uint64) = wgpuRenderBundleEncoderSetIndexBuffer(this, buffer, format, offset, size)
    /// <summary>
    /// Sets the active render pipeline.
    /// <br/>
    /// Subsequent draw calls will exhibit the behavior defined by pipeline.
    /// <br/>
    /// </summary>
    member this.SetPipeline(pipeline: RenderPipeline) = wgpuRenderBundleEncoderSetPipeline(this, pipeline)
    /// <summary>
    /// Assign a vertex buffer to a slot.
    /// <br/>
    /// Subsequent calls to draw and draw_indexed on this RenderBundleEncoder will use buffer as one of the source vertex buffers.
    /// <br/>
    /// The slot refers to the index of the matching descriptor in VertexState.Buffers.
    /// </summary>
    member this.SetVertexBuffer(slot: uint32, buffer: Buffer, offset: uint64, size: uint64) = wgpuRenderBundleEncoderSetVertexBuffer(this, slot, buffer, offset, size)
    override this.ToString() = $"%X{this.handle}"
and RenderBundleEncoderImpl = nativeint

/// <summary>
/// In-progress recording of a render pass.
/// </summary>
///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type RenderPassEncoder =
    struct
        val handle : RenderPassEncoderImpl
        new(ptr) = { handle = ptr }
    end
    member this.BeginOcclusionQuery(queryIndex: uint32) = wgpuRenderPassEncoderBeginOcclusionQuery(this, queryIndex)
    member this.BeginPipelineStatisticsQuery(querySet: QuerySet, queryIndex: uint32) = wgpuRenderPassEncoderBeginPipelineStatisticsQuery(this, querySet, queryIndex)
    /// <summary>
    /// Draws primitives from the active vertex buffer(s).
    /// <br/>
    /// The active vertex buffers can be set with RenderPass.SetVertexBuffer.
    /// </summary>
    member this.Draw(vertexCount: uint32, instanceCount: uint32, firstVertex: uint32, firstInstance: uint32) = wgpuRenderPassEncoderDraw(this, vertexCount, instanceCount, firstVertex, firstInstance)
    /// <summary>
    /// Draws indexed primitives using the active index buffer and the active vertex buffers.
    /// <br/>
    /// The active index buffer can be set with RenderPass.SetIndexBuffer, while the active vertex buffers can be set with RenderPass.SetVertexBuffer.
    /// <br/>
    /// </summary>
    member this.DrawIndexed(indexCount: uint32, instanceCount: uint32, firstIndex: uint32, baseVertex: int32, firstInstance: uint32) = wgpuRenderPassEncoderDrawIndexed(this, indexCount, instanceCount, firstIndex, baseVertex, firstInstance)
    /// <summary>
    /// Draws indexed primitives using the active index buffer and the active vertex buffers, based on the contents of the indirect_buffer.
    /// <br/>
    /// The active index buffer can be set with RenderPass.SetIndexBuffer, while the active vertex buffers can be set with RenderPass.SetVertexBuffer.
    /// </summary>
    member this.DrawIndexedIndirect(indirectBuffer: Buffer, indirectOffset: uint64) = wgpuRenderPassEncoderDrawIndexedIndirect(this, indirectBuffer, indirectOffset)
    /// <summary>
    /// Draws primitives from the active vertex buffer(s) based on the contents of the indirect_buffer.
    /// <br/>
    /// The active vertex buffers can be set with RenderPass.SetVertexBuffer.
    /// </summary>
    member this.DrawIndirect(indirectBuffer: Buffer, indirectOffset: uint64) = wgpuRenderPassEncoderDrawIndirect(this, indirectBuffer, indirectOffset)
    member this.End() = wgpuRenderPassEncoderEnd(this)
    member this.EndOcclusionQuery() = wgpuRenderPassEncoderEndOcclusionQuery(this)
    /// <summary>
    /// End the pipeline statistics query on this render pass. It can be started with begin_pipeline_statistics_query. Pipeline statistics queries may not be nested.
    /// </summary>
    member this.EndPipelineStatisticsQuery() = wgpuRenderPassEncoderEndPipelineStatisticsQuery(this)
    /// <summary>
    /// Execute a render bundle, which is a set of pre-recorded commands that can be run together.
    /// </summary>
    member this.ExecuteBundles(bundlesCount: uint32, bundles: RenderBundle nativeptr) = wgpuRenderPassEncoderExecuteBundles(this, bundlesCount, bundles)
    member this.InsertDebugMarker(markerLabel: string) = wgpuRenderPassEncoderInsertDebugMarker(this, markerLabel)
    member this.PopDebugGroup() = wgpuRenderPassEncoderPopDebugGroup(this)
    member this.PushDebugGroup(groupLabel: string) = wgpuRenderPassEncoderPushDebugGroup(this, groupLabel)
    /// <summary>
    /// Sets the active bind group for a given bind group index. The bind group layout in the active pipeline when any draw() function is called must match the layout of this bind group.
    /// <br/>
    /// If the bind group have dynamic offsets, provide them in binding order. These offsets have to be aligned to Limits.minUniformBufferOffsetAlignment or Limits.minStorageBufferOffsetAlignment appropriately.
    /// <br/>
    /// </summary>
    member this.SetBindGroup(groupIndex: uint32, group: BindGroup, dynamicOffsetCount: uint32, dynamicOffsets: uint32 nativeptr) = wgpuRenderPassEncoderSetBindGroup(this, groupIndex, group, dynamicOffsetCount, dynamicOffsets)
    /// <summary>
    /// Sets the blend color as used by some of the blending modes.
    /// <br/>
    /// Subsequent blending tests will test against this value.
    /// </summary>
    member this.SetBlendConstant(color: Color nativeptr) = wgpuRenderPassEncoderSetBlendConstant(this, color)
    /// <summary>
    /// Sets the active index buffer.
    /// <br/>
    /// Subsequent calls to draw_indexed on this RenderPass will use buffer as the source index buffer.
    /// </summary>
    member this.SetIndexBuffer(buffer: Buffer, format: IndexFormat, offset: uint64, size: uint64) = wgpuRenderPassEncoderSetIndexBuffer(this, buffer, format, offset, size)
    /// <summary>
    /// Sets the active render pipeline.
    /// <br/>
    /// Subsequent draw calls will exhibit the behavior defined by pipeline.
    /// </summary>
    member this.SetPipeline(pipeline: RenderPipeline) = wgpuRenderPassEncoderSetPipeline(this, pipeline)
    /// <summary>
    /// Sets the scissor region.
    /// <br/>
    /// Subsequent draw calls will discard any fragments that fall outside this region.
    /// </summary>
    member this.SetScissorRect(x: uint32, y: uint32, width: uint32, height: uint32) = wgpuRenderPassEncoderSetScissorRect(this, x, y, width, height)
    /// <summary>
    /// Sets the stencil reference.
    /// <br/>
    /// Subsequent stencil tests will test against this value.
    /// </summary>
    member this.SetStencilReference(reference: uint32) = wgpuRenderPassEncoderSetStencilReference(this, reference)
    /// <summary>
    /// Assign a vertex buffer to a slot.
    /// <br/>
    /// Subsequent calls to draw and draw_indexed on this RenderPass will use buffer as one of the source vertex buffers.
    /// <br/>
    /// The slot refers to the index of the matching descriptor in VertexState.Buffers.
    /// </summary>
    member this.SetVertexBuffer(slot: uint32, buffer: Buffer, offset: uint64, size: uint64) = wgpuRenderPassEncoderSetVertexBuffer(this, slot, buffer, offset, size)
    /// <summary>
    /// Sets the viewport region.
    /// <br/>
    /// Subsequent draw calls will draw any fragments in this region.
    /// </summary>
    member this.SetViewport(x: float, y: float, width: float, height: float, minDepth: float, maxDepth: float) = wgpuRenderPassEncoderSetViewport(this, x, y, width, height, minDepth, maxDepth)
    /// <summary>
    /// Set push constant data.
    /// <br/>
    /// Offset is measured in bytes, but must be a multiple of PUSH_CONSTANT_ALIGNMENT.
    /// <br/>
    /// Data size must be a multiple of 4 and must be aligned to the 4s, so we take an array of u32. For example, with an offset of 4 and an array of [u32; 3], that will write to the range of 4..16.
    /// <br/>
    /// For each byte in the range of push constant data written, the union of the stages of all push constant ranges that covers that byte must be exactly stages. There’s no good way of explaining this simply, so here are some examples:
    /// <br/>
    /// For the given ranges:
    /// - 0..4 Vertex
    /// - 4..8 Fragment
    /// <br/>
    /// You would need to upload this in two set_push_constants calls. First for the Vertex range, second for the Fragment range.
    /// <br/>
    /// For the given ranges:
    /// - 0..8  Vertex
    /// - 4..12 Fragment
    /// <br/>
    /// You would need to upload this in three set_push_constants calls. First for the Vertex only range 0..4, second for the Vertex | Fragment range 4..8, third for the Fragment range 8..12.
    /// </summary>
    member this.SetPushConstants(stages: ShaderStage, offset: uint32, sizeBytes: uint32, data: nativeint) = wgpuRenderPassEncoderSetPushConstants(this, stages, offset, sizeBytes, data)
    override this.ToString() = $"%X{this.handle}"
and RenderPassEncoderImpl = nativeint

/// <summary>
/// Handle to a rendering (graphics) pipeline.
/// <br/>
/// A RenderPipeline object represents a graphics pipeline and its stages, bindings, vertex buffers and targets. A RenderPipeline may be created with Device.CreateRenderPipeline.
/// <br/>
/// </summary>
///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type RenderPipeline =
    struct
        val handle : RenderPipelineImpl
        new(ptr) = { handle = ptr }
    end
    /// <summary>
    /// Get an object representing the bind group layout at a given index.
    /// </summary>
    member this.GetBindGroupLayout(groupIndex: uint32) = wgpuRenderPipelineGetBindGroupLayout(this, groupIndex)
    member this.SetLabel(label: string) = wgpuRenderPipelineSetLabel(this, label)
    /// <summary>
    /// Executes the destructor for this type.
    /// </summary>
    member this.Drop() = wgpuRenderPipelineDrop(this)
    override this.ToString() = $"%X{this.handle}"
and RenderPipelineImpl = nativeint

/// <summary>
/// Handle to a sampler.
/// <br/>
/// A Sampler object defines how a pipeline will sample from a TextureView. Samplers define image filters (including anisotropy) and address (wrapping) modes, among other things. See the documentation for SamplerDescriptor for more information.
/// </summary>
///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type Sampler =
    struct
        val handle : SamplerImpl
        new(ptr) = { handle = ptr }
    end
    /// <summary>
    /// Executes the destructor for this type.
    /// </summary>
    member this.Drop() = wgpuSamplerDrop(this)
    override this.ToString() = $"%X{this.handle}"
and SamplerImpl = nativeint

/// <summary>
/// Handle to a compiled shader module.
/// <br/>
/// A ShaderModule represents a compiled shader module on the GPU. It can be created by passing valid SPIR-V source code to Device.CreateShaderModule. Shader modules are used to define programmable stages of a pipeline.
/// </summary>
///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type ShaderModule =
    struct
        val handle : ShaderModuleImpl
        new(ptr) = { handle = ptr }
    end
    member this.GetCompilationInfo(callback: CompilationInfoCallback, userdata: nativeint) = wgpuShaderModuleGetCompilationInfo(this, callback, userdata)
    member this.SetLabel(label: string) = wgpuShaderModuleSetLabel(this, label)
    /// <summary>
    /// Executes the destructor for this type.
    /// </summary>
    member this.Drop() = wgpuShaderModuleDrop(this)
    override this.ToString() = $"%X{this.handle}"
and ShaderModuleImpl = nativeint

/// <summary>
/// Handle to a presentable surface.
/// <br/>
/// A Surface represents a platform-specific surface (e.g. a window) onto which rendered images may be presented. A Surface may be created with the unsafe function Instance.CreateSurface.
/// </summary>
///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type Surface =
    struct
        val handle : SurfaceImpl
        new(ptr) = { handle = ptr }
    end
    /// <summary>
    /// Returns an optimal texture format to use for the Surface with this adapter.
    /// <br/>
    /// Returns None if the surface is incompatible with the adapter.
    /// </summary>
    member this.GetPreferredFormat(adapter: Adapter) = wgpuSurfaceGetPreferredFormat(this, adapter)
    override this.ToString() = $"%X{this.handle}"
and SurfaceImpl = nativeint

/// <summary>
/// A collection of buffers that are used for displaying rendered textures to the user.
/// </summary>
///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type SwapChain =
    struct
        val handle : SwapChainImpl
        new(ptr) = { handle = ptr }
    end
    /// <summary>
    /// Returns the TextureView to be used as a render target for command encoding.
    /// </summary>
    member this.GetCurrentTextureView() = wgpuSwapChainGetCurrentTextureView(this)
    /// <summary>
    /// Swaps the currently presented texture with the next frame in flight.
    /// </summary>
    member this.Present() = wgpuSwapChainPresent(this)
    override this.ToString() = $"%X{this.handle}"
and SwapChainImpl = nativeint

/// <summary>
/// Handle to a texture on the GPU.
/// <br/>
/// Created by calling Device.CreateTexture.
/// </summary>
///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type Texture =
    struct
        val handle : TextureImpl
        new(ptr) = { handle = ptr }
    end
    /// <summary>
    /// Creates a view of this texture.
    /// </summary>
    member this.CreateView(descriptor: TextureViewDescriptor byref) = wgpuTextureCreateView(this, &descriptor)
    /// <summary>
    /// Destroy the associated native resources as soon as possible.
    /// </summary>
    member this.Destroy() = wgpuTextureDestroy(this)
    /// <summary>
    /// Executes the destructor for this type.
    /// </summary>
    member this.Drop() = wgpuTextureDrop(this)
    override this.ToString() = $"%X{this.handle}"
and TextureImpl = nativeint

/// <summary>
/// Handle to a texture view.
/// <br/>
/// A TextureView object describes a texture and associated metadata needed by a RenderPipeline or BindGroup.
/// </summary>
///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type TextureView =
    struct
        val handle : TextureViewImpl
        new(ptr) = { handle = ptr }
    end
    /// <summary>
    /// Executes the destructor for this type.
    /// </summary>
    member this.Drop() = wgpuTextureViewDrop(this)
    override this.ToString() = $"%X{this.handle}"
and TextureViewImpl = nativeint

type AdapterType =
    | DiscreteGPU = 0
    | IntegratedGPU = 1
    | CPU = 2
    | Unknown = 3

type AddressMode =
    | Repeat = 0
    | MirrorRepeat = 1
    | ClampToEdge = 2

type BackendType =
    | Null = 0
    | WebGPU = 1
    | D3D11 = 2
    | D3D12 = 3
    | Metal = 4
    | Vulkan = 5
    | OpenGL = 6
    | OpenGLES = 7

type BlendFactor =
    | Zero = 0
    | One = 1
    | Src = 2
    | OneMinusSrc = 3
    | SrcAlpha = 4
    | OneMinusSrcAlpha = 5
    | Dst = 6
    | OneMinusDst = 7
    | DstAlpha = 8
    | OneMinusDstAlpha = 9
    | SrcAlphaSaturated = 10
    | Constant = 11
    | OneMinusConstant = 12

type BlendOperation =
    | Add = 0
    | Subtract = 1
    | ReverseSubtract = 2
    | Min = 3
    | Max = 4

type BufferBindingType =
    | Undefined = 0
    | Uniform = 1
    | Storage = 2
    | ReadOnlyStorage = 3

type BufferMapAsyncStatus =
    | Success = 0
    | Error = 1
    | Unknown = 2
    | DeviceLost = 3
    | DestroyedBeforeCallback = 4
    | UnmappedBeforeCallback = 5

type CompareFunction =
    | Undefined = 0
    | Never = 1
    | Less = 2
    | LessEqual = 3
    | Greater = 4
    | GreaterEqual = 5
    | Equal = 6
    | NotEqual = 7
    | Always = 8

type CompilationInfoRequestStatus =
    | Success = 0
    | Error = 1
    | DeviceLost = 2
    | Unknown = 3

type CompilationMessageType =
    | Error = 0
    | Warning = 1
    | Info = 2

type ComputePassTimestampLocation =
    | Beginning = 0
    | End = 1

type CreatePipelineAsyncStatus =
    | Success = 0
    | Error = 1
    | DeviceLost = 2
    | DeviceDestroyed = 3
    | Unknown = 4

type CullMode =
    | None = 0
    | Front = 1
    | Back = 2

type DeviceLostReason =
    | Undefined = 0
    | Destroyed = 1

type ErrorFilter =
    | Validation = 0
    | OutOfMemory = 1

type ErrorType =
    | NoError = 0
    | Validation = 1
    | OutOfMemory = 2
    | Unknown = 3
    | DeviceLost = 4

type FeatureName =
    | Undefined = 0
    | DepthClipControl = 1
    | Depth24UnormStencil8 = 2
    | Depth32FloatStencil8 = 3
    | TimestampQuery = 4
    | PipelineStatisticsQuery = 5
    | TextureCompressionBC = 6
    | TextureCompressionETC2 = 7
    | TextureCompressionASTC = 8
    | IndirectFirstInstance = 9

type FilterMode =
    | Nearest = 0
    | Linear = 1

type FrontFace =
    | CCW = 0
    | CW = 1

type IndexFormat =
    | Undefined = 0
    | Uint16 = 1
    | Uint32 = 2

type LoadOp =
    | Undefined = 0
    | Clear = 1
    | Load = 2

type MipmapFilterMode =
    | Nearest = 0
    | Linear = 1

type PipelineStatisticName =
    | VertexShaderInvocations = 0
    | ClipperInvocations = 1
    | ClipperPrimitivesOut = 2
    | FragmentShaderInvocations = 3
    | ComputeShaderInvocations = 4

type PowerPreference =
    | Undefined = 0
    | LowPower = 1
    | HighPerformance = 2

type PredefinedColorSpace =
    | Undefined = 0
    | Srgb = 1

type PresentMode =
    | Immediate = 0
    | Mailbox = 1
    | Fifo = 2

type PrimitiveTopology =
    | PointList = 0
    | LineList = 1
    | LineStrip = 2
    | TriangleList = 3
    | TriangleStrip = 4

type QueryType =
    | Occlusion = 0
    | PipelineStatistics = 1
    | Timestamp = 2

type QueueWorkDoneStatus =
    | Success = 0
    | Error = 1
    | Unknown = 2
    | DeviceLost = 3

type RenderPassTimestampLocation =
    | Beginning = 0
    | End = 1

type RequestAdapterStatus =
    | Success = 0
    | Unavailable = 1
    | Error = 2
    | Unknown = 3

type RequestDeviceStatus =
    | Success = 0
    | Error = 1
    | Unknown = 2

type SType =
    | Invalid = 0
    | SurfaceDescriptorFromMetalLayer = 1
    | SurfaceDescriptorFromWindowsHWND = 2
    | SurfaceDescriptorFromXlibWindow = 3
    | SurfaceDescriptorFromCanvasHTMLSelector = 4
    | ShaderModuleSPIRVDescriptor = 5
    | ShaderModuleWGSLDescriptor = 6
    | PrimitiveDepthClipControl = 7
    | SurfaceDescriptorFromWaylandSurface = 8
    | SurfaceDescriptorFromAndroidNativeWindow = 9
    | SurfaceDescriptorFromXcbWindow = 10

type SamplerBindingType =
    | Undefined = 0
    | Filtering = 1
    | NonFiltering = 2
    | Comparison = 3

type StencilOperation =
    | Keep = 0
    | Zero = 1
    | Replace = 2
    | Invert = 3
    | IncrementClamp = 4
    | DecrementClamp = 5
    | IncrementWrap = 6
    | DecrementWrap = 7

type StorageTextureAccess =
    | Undefined = 0
    | WriteOnly = 1

type StoreOp =
    | Undefined = 0
    | Store = 1
    | Discard = 2

type TextureAspect =
    | All = 0
    | StencilOnly = 1
    | DepthOnly = 2

type TextureComponentType =
    | Float = 0
    | Sint = 1
    | Uint = 2
    | DepthComparison = 3

type TextureDimension =
    | OneDimensional = 0
    | TwoDimensional = 1
    | ThreeDimensional = 2

type TextureFormat =
    | Undefined = 0
    | R8Unorm = 1
    | R8Snorm = 2
    | R8Uint = 3
    | R8Sint = 4
    | R16Uint = 5
    | R16Sint = 6
    | R16Float = 7
    | RG8Unorm = 8
    | RG8Snorm = 9
    | RG8Uint = 10
    | RG8Sint = 11
    | R32Float = 12
    | R32Uint = 13
    | R32Sint = 14
    | RG16Uint = 15
    | RG16Sint = 16
    | RG16Float = 17
    | RGBA8Unorm = 18
    | RGBA8UnormSrgb = 19
    | RGBA8Snorm = 20
    | RGBA8Uint = 21
    | RGBA8Sint = 22
    | BGRA8Unorm = 23
    | BGRA8UnormSrgb = 24
    | RGB10A2Unorm = 25
    | RG11B10Ufloat = 26
    | RGB9E5Ufloat = 27
    | RG32Float = 28
    | RG32Uint = 29
    | RG32Sint = 30
    | RGBA16Uint = 31
    | RGBA16Sint = 32
    | RGBA16Float = 33
    | RGBA32Float = 34
    | RGBA32Uint = 35
    | RGBA32Sint = 36
    | Stencil8 = 37
    | Depth16Unorm = 38
    | Depth24Plus = 39
    | Depth24PlusStencil8 = 40
    | Depth24UnormStencil8 = 41
    | Depth32Float = 42
    | Depth32FloatStencil8 = 43
    | BC1RGBAUnorm = 44
    | BC1RGBAUnormSrgb = 45
    | BC2RGBAUnorm = 46
    | BC2RGBAUnormSrgb = 47
    | BC3RGBAUnorm = 48
    | BC3RGBAUnormSrgb = 49
    | BC4RUnorm = 50
    | BC4RSnorm = 51
    | BC5RGUnorm = 52
    | BC5RGSnorm = 53
    | BC6HRGBUfloat = 54
    | BC6HRGBFloat = 55
    | BC7RGBAUnorm = 56
    | BC7RGBAUnormSrgb = 57
    | ETC2RGB8Unorm = 58
    | ETC2RGB8UnormSrgb = 59
    | ETC2RGB8A1Unorm = 60
    | ETC2RGB8A1UnormSrgb = 61
    | ETC2RGBA8Unorm = 62
    | ETC2RGBA8UnormSrgb = 63
    | EACR11Unorm = 64
    | EACR11Snorm = 65
    | EACRG11Unorm = 66
    | EACRG11Snorm = 67
    | ASTC4x4Unorm = 68
    | ASTC4x4UnormSrgb = 69
    | ASTC5x4Unorm = 70
    | ASTC5x4UnormSrgb = 71
    | ASTC5x5Unorm = 72
    | ASTC5x5UnormSrgb = 73
    | ASTC6x5Unorm = 74
    | ASTC6x5UnormSrgb = 75
    | ASTC6x6Unorm = 76
    | ASTC6x6UnormSrgb = 77
    | ASTC8x5Unorm = 78
    | ASTC8x5UnormSrgb = 79
    | ASTC8x6Unorm = 80
    | ASTC8x6UnormSrgb = 81
    | ASTC8x8Unorm = 82
    | ASTC8x8UnormSrgb = 83
    | ASTC10x5Unorm = 84
    | ASTC10x5UnormSrgb = 85
    | ASTC10x6Unorm = 86
    | ASTC10x6UnormSrgb = 87
    | ASTC10x8Unorm = 88
    | ASTC10x8UnormSrgb = 89
    | ASTC10x10Unorm = 90
    | ASTC10x10UnormSrgb = 91
    | ASTC12x10Unorm = 92
    | ASTC12x10UnormSrgb = 93
    | ASTC12x12Unorm = 94
    | ASTC12x12UnormSrgb = 95

type TextureSampleType =
    | Undefined = 0
    | Float = 1
    | UnfilterableFloat = 2
    | Depth = 3
    | Sint = 4
    | Uint = 5

type TextureViewDimension =
    | Undefined = 0
    | OneDimensional = 1
    | TwoDimensional = 2
    | TwoDimensionalArray = 3
    | Cube = 4
    | CubeArray = 5
    | ThreeDimensional = 6

type VertexFormat =
    | Undefined = 0
    | Uint8x2 = 1
    | Uint8x4 = 2
    | Sint8x2 = 3
    | Sint8x4 = 4
    | Unorm8x2 = 5
    | Unorm8x4 = 6
    | Snorm8x2 = 7
    | Snorm8x4 = 8
    | Uint16x2 = 9
    | Uint16x4 = 10
    | Sint16x2 = 11
    | Sint16x4 = 12
    | Unorm16x2 = 13
    | Unorm16x4 = 14
    | Snorm16x2 = 15
    | Snorm16x4 = 16
    | Float16x2 = 17
    | Float16x4 = 18
    | Float32 = 19
    | Float32x2 = 20
    | Float32x3 = 21
    | Float32x4 = 22
    | Uint32 = 23
    | Uint32x2 = 24
    | Uint32x3 = 25
    | Uint32x4 = 26
    | Sint32 = 27
    | Sint32x2 = 28
    | Sint32x3 = 29
    | Sint32x4 = 30

type VertexStepMode =
    | Vertex = 0
    | Instance = 1

[<Flags>]
type BufferUsage =
    | None = 0
    | MapRead = 1
    | MapWrite = 2
    | CopySrc = 4
    | CopyDst = 8
    | Index = 16
    | Vertex = 32
    | Uniform = 64
    | Storage = 128
    | Indirect = 256
    | QueryResolve = 512

[<Flags>]
type ColorWriteMask =
    | None = 0
    | Red = 1
    | Green = 2
    | Blue = 4
    | Alpha = 8
    | All = 15

[<Flags>]
type MapMode =
    | None = 0
    | Read = 1
    | Write = 2

[<Flags>]
type ShaderStage =
    | None = 0
    | Vertex = 1
    | Fragment = 2
    | Compute = 4

[<Flags>]
type TextureUsage =
    | None = 0
    | CopySrc = 1
    | CopyDst = 2
    | TextureBinding = 4
    | StorageBinding = 8
    | RenderAttachment = 16

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type ChainedStruct =
    struct
        ///ChainedStruct inref
        val Next : nativeint
        val SType : SType
        new (?next : nativeint, ?sType : SType) = {Next = Option.defaultValue IntPtr.Zero next ; SType = Option.defaultValue Unchecked.defaultof<SType> sType}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type ChainedStructOut =
    struct
        ///ChainedStructOut byref
        val Next : nativeint
        val SType : SType
        new (?next : nativeint, ?sType : SType) = {Next = Option.defaultValue IntPtr.Zero next ; SType = Option.defaultValue Unchecked.defaultof<SType> sType}
    end

///(Managed type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type AdapterProperties =
    struct
        ///ChainedStructOut byref
        val NextInChain : nativeint
        val VendorID : uint32
        val DeviceID : uint32
        [<MarshalAs(UnmanagedType.LPStr)>]
        val Name : string
        [<MarshalAs(UnmanagedType.LPStr)>]
        val DriverDescription : string
        val AdapterType : AdapterType
        val BackendType : BackendType
        new (?nextInChain : nativeint, ?vendorID : uint32, ?deviceID : uint32, ?name : string, ?driverDescription : string, ?adapterType : AdapterType, ?backendType : BackendType) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; VendorID = Option.defaultValue Unchecked.defaultof<uint32> vendorID ; DeviceID = Option.defaultValue Unchecked.defaultof<uint32> deviceID ; Name = Option.defaultValue Unchecked.defaultof<string> name ; DriverDescription = Option.defaultValue Unchecked.defaultof<string> driverDescription ; AdapterType = Option.defaultValue Unchecked.defaultof<AdapterType> adapterType ; BackendType = Option.defaultValue Unchecked.defaultof<BackendType> backendType}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type BindGroupEntry =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        val Binding : uint32
        val Buffer : Buffer
        val Offset : uint64
        val Size : uint64
        val Sampler : Sampler
        val TextureView : TextureView
        new (?nextInChain : nativeint, ?binding : uint32, ?buffer : Buffer, ?offset : uint64, ?size : uint64, ?sampler : Sampler, ?textureView : TextureView) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Binding = Option.defaultValue Unchecked.defaultof<uint32> binding ; Buffer = Option.defaultValue Unchecked.defaultof<Buffer> buffer ; Offset = Option.defaultValue Unchecked.defaultof<uint64> offset ; Size = Option.defaultValue Unchecked.defaultof<uint64> size ; Sampler = Option.defaultValue Unchecked.defaultof<Sampler> sampler ; TextureView = Option.defaultValue Unchecked.defaultof<TextureView> textureView}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type BlendComponent =
    struct
        val Operation : BlendOperation
        val SrcFactor : BlendFactor
        val DstFactor : BlendFactor
        new (?operation : BlendOperation, ?srcFactor : BlendFactor, ?dstFactor : BlendFactor) = {Operation = Option.defaultValue Unchecked.defaultof<BlendOperation> operation ; SrcFactor = Option.defaultValue Unchecked.defaultof<BlendFactor> srcFactor ; DstFactor = Option.defaultValue Unchecked.defaultof<BlendFactor> dstFactor}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type BufferBindingLayout =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        val Type : BufferBindingType
        [<MarshalAs(UnmanagedType.U1)>]
        val HasDynamicOffset : bool
        val MinBindingSize : uint64
        new (?nextInChain : nativeint, ?``type`` : BufferBindingType, ?hasDynamicOffset : bool, ?minBindingSize : uint64) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Type = Option.defaultValue Unchecked.defaultof<BufferBindingType> ``type`` ; HasDynamicOffset = Option.defaultValue Unchecked.defaultof<bool> hasDynamicOffset ; MinBindingSize = Option.defaultValue Unchecked.defaultof<uint64> minBindingSize}
    end

///(Managed type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type BufferDescriptor =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        [<MarshalAs(UnmanagedType.LPStr)>]
        val Label : string
        val Usage : BufferUsage
        val Size : uint64
        [<MarshalAs(UnmanagedType.U1)>]
        val MappedAtCreation : bool
        new (?nextInChain : nativeint, ?label : string, ?usage : BufferUsage, ?size : uint64, ?mappedAtCreation : bool) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Label = Option.defaultValue Unchecked.defaultof<string> label ; Usage = Option.defaultValue Unchecked.defaultof<BufferUsage> usage ; Size = Option.defaultValue Unchecked.defaultof<uint64> size ; MappedAtCreation = Option.defaultValue Unchecked.defaultof<bool> mappedAtCreation}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type Color =
    struct
        val R : double
        val G : double
        val B : double
        val A : double
        new (?r : double, ?g : double, ?b : double, ?a : double) = {R = Option.defaultValue Unchecked.defaultof<double> r ; G = Option.defaultValue Unchecked.defaultof<double> g ; B = Option.defaultValue Unchecked.defaultof<double> b ; A = Option.defaultValue Unchecked.defaultof<double> a}
    end

///(Managed type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type CommandBufferDescriptor =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        [<MarshalAs(UnmanagedType.LPStr)>]
        val Label : string
        new (?nextInChain : nativeint, ?label : string) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Label = Option.defaultValue Unchecked.defaultof<string> label}
    end

///(Managed type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type CommandEncoderDescriptor =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        [<MarshalAs(UnmanagedType.LPStr)>]
        val Label : string
        new (?nextInChain : nativeint, ?label : string) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Label = Option.defaultValue Unchecked.defaultof<string> label}
    end

///(Managed type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type CompilationMessage =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        [<MarshalAs(UnmanagedType.LPStr)>]
        val Message : string
        val Type : CompilationMessageType
        val LineNum : uint64
        val LinePos : uint64
        val Offset : uint64
        val Length : uint64
        new (?nextInChain : nativeint, ?message : string, ?``type`` : CompilationMessageType, ?lineNum : uint64, ?linePos : uint64, ?offset : uint64, ?length : uint64) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Message = Option.defaultValue Unchecked.defaultof<string> message ; Type = Option.defaultValue Unchecked.defaultof<CompilationMessageType> ``type`` ; LineNum = Option.defaultValue Unchecked.defaultof<uint64> lineNum ; LinePos = Option.defaultValue Unchecked.defaultof<uint64> linePos ; Offset = Option.defaultValue Unchecked.defaultof<uint64> offset ; Length = Option.defaultValue Unchecked.defaultof<uint64> length}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type ComputePassTimestampWrite =
    struct
        val QuerySet : QuerySet
        val QueryIndex : uint32
        val Location : ComputePassTimestampLocation
        new (?querySet : QuerySet, ?queryIndex : uint32, ?location : ComputePassTimestampLocation) = {QuerySet = Option.defaultValue Unchecked.defaultof<QuerySet> querySet ; QueryIndex = Option.defaultValue Unchecked.defaultof<uint32> queryIndex ; Location = Option.defaultValue Unchecked.defaultof<ComputePassTimestampLocation> location}
    end

///(Managed type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type ConstantEntry =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        [<MarshalAs(UnmanagedType.LPStr)>]
        val Key : string
        val Value : double
        new (?nextInChain : nativeint, ?key : string, ?value : double) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Key = Option.defaultValue Unchecked.defaultof<string> key ; Value = Option.defaultValue Unchecked.defaultof<double> value}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type Extent3D =
    struct
        val Width : uint32
        val Height : uint32
        val DepthOrArrayLayers : uint32
        new (?width : uint32, ?height : uint32, ?depthOrArrayLayers : uint32) = {Width = Option.defaultValue Unchecked.defaultof<uint32> width ; Height = Option.defaultValue Unchecked.defaultof<uint32> height ; DepthOrArrayLayers = Option.defaultValue Unchecked.defaultof<uint32> depthOrArrayLayers}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type InstanceDescriptor =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        new (?nextInChain : nativeint) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type Limits =
    struct
        val MaxTextureDimension1D : uint32
        val MaxTextureDimension2D : uint32
        val MaxTextureDimension3D : uint32
        val MaxTextureArrayLayers : uint32
        val MaxBindGroups : uint32
        val MaxDynamicUniformBuffersPerPipelineLayout : uint32
        val MaxDynamicStorageBuffersPerPipelineLayout : uint32
        val MaxSampledTexturesPerShaderStage : uint32
        val MaxSamplersPerShaderStage : uint32
        val MaxStorageBuffersPerShaderStage : uint32
        val MaxStorageTexturesPerShaderStage : uint32
        val MaxUniformBuffersPerShaderStage : uint32
        val MaxUniformBufferBindingSize : uint64
        val MaxStorageBufferBindingSize : uint64
        val MinUniformBufferOffsetAlignment : uint32
        val MinStorageBufferOffsetAlignment : uint32
        val MaxVertexBuffers : uint32
        val MaxVertexAttributes : uint32
        val MaxVertexBufferArrayStride : uint32
        val MaxInterStageShaderComponents : uint32
        val MaxComputeWorkgroupStorageSize : uint32
        val MaxComputeInvocationsPerWorkgroup : uint32
        val MaxComputeWorkgroupSizeX : uint32
        val MaxComputeWorkgroupSizeY : uint32
        val MaxComputeWorkgroupSizeZ : uint32
        val MaxComputeWorkgroupsPerDimension : uint32
        new (?maxTextureDimension1D : uint32, ?maxTextureDimension2D : uint32, ?maxTextureDimension3D : uint32, ?maxTextureArrayLayers : uint32, ?maxBindGroups : uint32, ?maxDynamicUniformBuffersPerPipelineLayout : uint32, ?maxDynamicStorageBuffersPerPipelineLayout : uint32, ?maxSampledTexturesPerShaderStage : uint32, ?maxSamplersPerShaderStage : uint32, ?maxStorageBuffersPerShaderStage : uint32, ?maxStorageTexturesPerShaderStage : uint32, ?maxUniformBuffersPerShaderStage : uint32, ?maxUniformBufferBindingSize : uint64, ?maxStorageBufferBindingSize : uint64, ?minUniformBufferOffsetAlignment : uint32, ?minStorageBufferOffsetAlignment : uint32, ?maxVertexBuffers : uint32, ?maxVertexAttributes : uint32, ?maxVertexBufferArrayStride : uint32, ?maxInterStageShaderComponents : uint32, ?maxComputeWorkgroupStorageSize : uint32, ?maxComputeInvocationsPerWorkgroup : uint32, ?maxComputeWorkgroupSizeX : uint32, ?maxComputeWorkgroupSizeY : uint32, ?maxComputeWorkgroupSizeZ : uint32, ?maxComputeWorkgroupsPerDimension : uint32) = {MaxTextureDimension1D = Option.defaultValue Unchecked.defaultof<uint32> maxTextureDimension1D ; MaxTextureDimension2D = Option.defaultValue Unchecked.defaultof<uint32> maxTextureDimension2D ; MaxTextureDimension3D = Option.defaultValue Unchecked.defaultof<uint32> maxTextureDimension3D ; MaxTextureArrayLayers = Option.defaultValue Unchecked.defaultof<uint32> maxTextureArrayLayers ; MaxBindGroups = Option.defaultValue Unchecked.defaultof<uint32> maxBindGroups ; MaxDynamicUniformBuffersPerPipelineLayout = Option.defaultValue Unchecked.defaultof<uint32> maxDynamicUniformBuffersPerPipelineLayout ; MaxDynamicStorageBuffersPerPipelineLayout = Option.defaultValue Unchecked.defaultof<uint32> maxDynamicStorageBuffersPerPipelineLayout ; MaxSampledTexturesPerShaderStage = Option.defaultValue Unchecked.defaultof<uint32> maxSampledTexturesPerShaderStage ; MaxSamplersPerShaderStage = Option.defaultValue Unchecked.defaultof<uint32> maxSamplersPerShaderStage ; MaxStorageBuffersPerShaderStage = Option.defaultValue Unchecked.defaultof<uint32> maxStorageBuffersPerShaderStage ; MaxStorageTexturesPerShaderStage = Option.defaultValue Unchecked.defaultof<uint32> maxStorageTexturesPerShaderStage ; MaxUniformBuffersPerShaderStage = Option.defaultValue Unchecked.defaultof<uint32> maxUniformBuffersPerShaderStage ; MaxUniformBufferBindingSize = Option.defaultValue Unchecked.defaultof<uint64> maxUniformBufferBindingSize ; MaxStorageBufferBindingSize = Option.defaultValue Unchecked.defaultof<uint64> maxStorageBufferBindingSize ; MinUniformBufferOffsetAlignment = Option.defaultValue Unchecked.defaultof<uint32> minUniformBufferOffsetAlignment ; MinStorageBufferOffsetAlignment = Option.defaultValue Unchecked.defaultof<uint32> minStorageBufferOffsetAlignment ; MaxVertexBuffers = Option.defaultValue Unchecked.defaultof<uint32> maxVertexBuffers ; MaxVertexAttributes = Option.defaultValue Unchecked.defaultof<uint32> maxVertexAttributes ; MaxVertexBufferArrayStride = Option.defaultValue Unchecked.defaultof<uint32> maxVertexBufferArrayStride ; MaxInterStageShaderComponents = Option.defaultValue Unchecked.defaultof<uint32> maxInterStageShaderComponents ; MaxComputeWorkgroupStorageSize = Option.defaultValue Unchecked.defaultof<uint32> maxComputeWorkgroupStorageSize ; MaxComputeInvocationsPerWorkgroup = Option.defaultValue Unchecked.defaultof<uint32> maxComputeInvocationsPerWorkgroup ; MaxComputeWorkgroupSizeX = Option.defaultValue Unchecked.defaultof<uint32> maxComputeWorkgroupSizeX ; MaxComputeWorkgroupSizeY = Option.defaultValue Unchecked.defaultof<uint32> maxComputeWorkgroupSizeY ; MaxComputeWorkgroupSizeZ = Option.defaultValue Unchecked.defaultof<uint32> maxComputeWorkgroupSizeZ ; MaxComputeWorkgroupsPerDimension = Option.defaultValue Unchecked.defaultof<uint32> maxComputeWorkgroupsPerDimension}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type MultisampleState =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        val Count : uint32
        val Mask : uint32
        [<MarshalAs(UnmanagedType.U1)>]
        val AlphaToCoverageEnabled : bool
        new (?nextInChain : nativeint, ?count : uint32, ?mask : uint32, ?alphaToCoverageEnabled : bool) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Count = Option.defaultValue Unchecked.defaultof<uint32> count ; Mask = Option.defaultValue Unchecked.defaultof<uint32> mask ; AlphaToCoverageEnabled = Option.defaultValue Unchecked.defaultof<bool> alphaToCoverageEnabled}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type Origin3D =
    struct
        val X : uint32
        val Y : uint32
        val Z : uint32
        new (?x : uint32, ?y : uint32, ?z : uint32) = {X = Option.defaultValue Unchecked.defaultof<uint32> x ; Y = Option.defaultValue Unchecked.defaultof<uint32> y ; Z = Option.defaultValue Unchecked.defaultof<uint32> z}
    end

///(Managed type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type PipelineLayoutDescriptor =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        [<MarshalAs(UnmanagedType.LPStr)>]
        val Label : string
        val BindGroupLayoutCount : uint32
        ///BindGroupLayout inref
        val BindGroupLayouts : nativeint
        new (?nextInChain : nativeint, ?label : string, ?bindGroupLayoutCount : uint32, ?bindGroupLayouts : nativeint) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Label = Option.defaultValue Unchecked.defaultof<string> label ; BindGroupLayoutCount = Option.defaultValue Unchecked.defaultof<uint32> bindGroupLayoutCount ; BindGroupLayouts = Option.defaultValue IntPtr.Zero bindGroupLayouts}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type PrimitiveDepthClipControl =
    struct
        val Chain : ChainedStruct
        [<MarshalAs(UnmanagedType.U1)>]
        val UnclippedDepth : bool
        new (?chain : ChainedStruct, ?unclippedDepth : bool) = {Chain = Option.defaultValue Unchecked.defaultof<ChainedStruct> chain ; UnclippedDepth = Option.defaultValue Unchecked.defaultof<bool> unclippedDepth}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type PrimitiveState =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        val Topology : PrimitiveTopology
        val StripIndexFormat : IndexFormat
        val FrontFace : FrontFace
        val CullMode : CullMode
        new (?nextInChain : nativeint, ?topology : PrimitiveTopology, ?stripIndexFormat : IndexFormat, ?frontFace : FrontFace, ?cullMode : CullMode) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Topology = Option.defaultValue Unchecked.defaultof<PrimitiveTopology> topology ; StripIndexFormat = Option.defaultValue Unchecked.defaultof<IndexFormat> stripIndexFormat ; FrontFace = Option.defaultValue Unchecked.defaultof<FrontFace> frontFace ; CullMode = Option.defaultValue Unchecked.defaultof<CullMode> cullMode}
    end

///(Managed type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type QuerySetDescriptor =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        [<MarshalAs(UnmanagedType.LPStr)>]
        val Label : string
        val Type : QueryType
        val Count : uint32
        ///PipelineStatisticName inref
        val PipelineStatistics : nativeint
        val PipelineStatisticsCount : uint32
        new (?nextInChain : nativeint, ?label : string, ?``type`` : QueryType, ?count : uint32, ?pipelineStatistics : nativeint, ?pipelineStatisticsCount : uint32) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Label = Option.defaultValue Unchecked.defaultof<string> label ; Type = Option.defaultValue Unchecked.defaultof<QueryType> ``type`` ; Count = Option.defaultValue Unchecked.defaultof<uint32> count ; PipelineStatistics = Option.defaultValue IntPtr.Zero pipelineStatistics ; PipelineStatisticsCount = Option.defaultValue Unchecked.defaultof<uint32> pipelineStatisticsCount}
    end

///(Managed type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type QueueDescriptor =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        [<MarshalAs(UnmanagedType.LPStr)>]
        val Label : string
        new (?nextInChain : nativeint, ?label : string) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Label = Option.defaultValue Unchecked.defaultof<string> label}
    end

///(Managed type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type RenderBundleDescriptor =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        [<MarshalAs(UnmanagedType.LPStr)>]
        val Label : string
        new (?nextInChain : nativeint, ?label : string) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Label = Option.defaultValue Unchecked.defaultof<string> label}
    end

///(Managed type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type RenderBundleEncoderDescriptor =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        [<MarshalAs(UnmanagedType.LPStr)>]
        val Label : string
        val ColorFormatsCount : uint32
        ///TextureFormat inref
        val ColorFormats : nativeint
        val DepthStencilFormat : TextureFormat
        val SampleCount : uint32
        [<MarshalAs(UnmanagedType.U1)>]
        val DepthReadOnly : bool
        [<MarshalAs(UnmanagedType.U1)>]
        val StencilReadOnly : bool
        new (?nextInChain : nativeint, ?label : string, ?colorFormatsCount : uint32, ?colorFormats : nativeint, ?depthStencilFormat : TextureFormat, ?sampleCount : uint32, ?depthReadOnly : bool, ?stencilReadOnly : bool) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Label = Option.defaultValue Unchecked.defaultof<string> label ; ColorFormatsCount = Option.defaultValue Unchecked.defaultof<uint32> colorFormatsCount ; ColorFormats = Option.defaultValue IntPtr.Zero colorFormats ; DepthStencilFormat = Option.defaultValue Unchecked.defaultof<TextureFormat> depthStencilFormat ; SampleCount = Option.defaultValue Unchecked.defaultof<uint32> sampleCount ; DepthReadOnly = Option.defaultValue Unchecked.defaultof<bool> depthReadOnly ; StencilReadOnly = Option.defaultValue Unchecked.defaultof<bool> stencilReadOnly}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type RenderPassDepthStencilAttachment =
    struct
        val View : TextureView
        val DepthLoadOp : LoadOp
        val DepthStoreOp : StoreOp
        val DepthClearValue : float
        [<MarshalAs(UnmanagedType.U1)>]
        val DepthReadOnly : bool
        val StencilLoadOp : LoadOp
        val StencilStoreOp : StoreOp
        val StencilClearValue : uint32
        [<MarshalAs(UnmanagedType.U1)>]
        val StencilReadOnly : bool
        new (?view : TextureView, ?depthLoadOp : LoadOp, ?depthStoreOp : StoreOp, ?depthClearValue : float, ?depthReadOnly : bool, ?stencilLoadOp : LoadOp, ?stencilStoreOp : StoreOp, ?stencilClearValue : uint32, ?stencilReadOnly : bool) = {View = Option.defaultValue Unchecked.defaultof<TextureView> view ; DepthLoadOp = Option.defaultValue Unchecked.defaultof<LoadOp> depthLoadOp ; DepthStoreOp = Option.defaultValue Unchecked.defaultof<StoreOp> depthStoreOp ; DepthClearValue = Option.defaultValue Unchecked.defaultof<float> depthClearValue ; DepthReadOnly = Option.defaultValue Unchecked.defaultof<bool> depthReadOnly ; StencilLoadOp = Option.defaultValue Unchecked.defaultof<LoadOp> stencilLoadOp ; StencilStoreOp = Option.defaultValue Unchecked.defaultof<StoreOp> stencilStoreOp ; StencilClearValue = Option.defaultValue Unchecked.defaultof<uint32> stencilClearValue ; StencilReadOnly = Option.defaultValue Unchecked.defaultof<bool> stencilReadOnly}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type RenderPassTimestampWrite =
    struct
        val QuerySet : QuerySet
        val QueryIndex : uint32
        val Location : RenderPassTimestampLocation
        new (?querySet : QuerySet, ?queryIndex : uint32, ?location : RenderPassTimestampLocation) = {QuerySet = Option.defaultValue Unchecked.defaultof<QuerySet> querySet ; QueryIndex = Option.defaultValue Unchecked.defaultof<uint32> queryIndex ; Location = Option.defaultValue Unchecked.defaultof<RenderPassTimestampLocation> location}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type RequestAdapterOptions =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        val CompatibleSurface : Surface
        val PowerPreference : PowerPreference
        [<MarshalAs(UnmanagedType.U1)>]
        val ForceFallbackAdapter : bool
        new (?nextInChain : nativeint, ?compatibleSurface : Surface, ?powerPreference : PowerPreference, ?forceFallbackAdapter : bool) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; CompatibleSurface = Option.defaultValue Unchecked.defaultof<Surface> compatibleSurface ; PowerPreference = Option.defaultValue Unchecked.defaultof<PowerPreference> powerPreference ; ForceFallbackAdapter = Option.defaultValue Unchecked.defaultof<bool> forceFallbackAdapter}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type SamplerBindingLayout =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        val Type : SamplerBindingType
        new (?nextInChain : nativeint, ?``type`` : SamplerBindingType) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Type = Option.defaultValue Unchecked.defaultof<SamplerBindingType> ``type``}
    end

///(Managed type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type SamplerDescriptor =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        [<MarshalAs(UnmanagedType.LPStr)>]
        val Label : string
        val AddressModeU : AddressMode
        val AddressModeV : AddressMode
        val AddressModeW : AddressMode
        val MagFilter : FilterMode
        val MinFilter : FilterMode
        val MipmapFilter : MipmapFilterMode
        val LodMinClamp : float
        val LodMaxClamp : float
        val Compare : CompareFunction
        val MaxAnisotropy : uint16
        new (?nextInChain : nativeint, ?label : string, ?addressModeU : AddressMode, ?addressModeV : AddressMode, ?addressModeW : AddressMode, ?magFilter : FilterMode, ?minFilter : FilterMode, ?mipmapFilter : MipmapFilterMode, ?lodMinClamp : float, ?lodMaxClamp : float, ?compare : CompareFunction, ?maxAnisotropy : uint16) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Label = Option.defaultValue Unchecked.defaultof<string> label ; AddressModeU = Option.defaultValue Unchecked.defaultof<AddressMode> addressModeU ; AddressModeV = Option.defaultValue Unchecked.defaultof<AddressMode> addressModeV ; AddressModeW = Option.defaultValue Unchecked.defaultof<AddressMode> addressModeW ; MagFilter = Option.defaultValue Unchecked.defaultof<FilterMode> magFilter ; MinFilter = Option.defaultValue Unchecked.defaultof<FilterMode> minFilter ; MipmapFilter = Option.defaultValue Unchecked.defaultof<MipmapFilterMode> mipmapFilter ; LodMinClamp = Option.defaultValue Unchecked.defaultof<float> lodMinClamp ; LodMaxClamp = Option.defaultValue Unchecked.defaultof<float> lodMaxClamp ; Compare = Option.defaultValue Unchecked.defaultof<CompareFunction> compare ; MaxAnisotropy = Option.defaultValue Unchecked.defaultof<uint16> maxAnisotropy}
    end

///(Managed type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type ShaderModuleCompilationHint =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        [<MarshalAs(UnmanagedType.LPStr)>]
        val EntryPoint : string
        val Layout : PipelineLayout
        new (?nextInChain : nativeint, ?entryPoint : string, ?layout : PipelineLayout) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; EntryPoint = Option.defaultValue Unchecked.defaultof<string> entryPoint ; Layout = Option.defaultValue Unchecked.defaultof<PipelineLayout> layout}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type ShaderModuleSPIRVDescriptor =
    struct
        val Chain : ChainedStruct
        val CodeSize : uint32
        ///uint32 inref
        val Code : nativeint
        new (?chain : ChainedStruct, ?codeSize : uint32, ?code : nativeint) = {Chain = Option.defaultValue Unchecked.defaultof<ChainedStruct> chain ; CodeSize = Option.defaultValue Unchecked.defaultof<uint32> codeSize ; Code = Option.defaultValue IntPtr.Zero code}
    end

///(Managed type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type ShaderModuleWGSLDescriptor =
    struct
        val Chain : ChainedStruct
        [<MarshalAs(UnmanagedType.LPStr)>]
        val Code : string
        new (?chain : ChainedStruct, ?code : string) = {Chain = Option.defaultValue Unchecked.defaultof<ChainedStruct> chain ; Code = Option.defaultValue Unchecked.defaultof<string> code}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type StencilFaceState =
    struct
        val Compare : CompareFunction
        val FailOp : StencilOperation
        val DepthFailOp : StencilOperation
        val PassOp : StencilOperation
        new (?compare : CompareFunction, ?failOp : StencilOperation, ?depthFailOp : StencilOperation, ?passOp : StencilOperation) = {Compare = Option.defaultValue Unchecked.defaultof<CompareFunction> compare ; FailOp = Option.defaultValue Unchecked.defaultof<StencilOperation> failOp ; DepthFailOp = Option.defaultValue Unchecked.defaultof<StencilOperation> depthFailOp ; PassOp = Option.defaultValue Unchecked.defaultof<StencilOperation> passOp}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type StorageTextureBindingLayout =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        val Access : StorageTextureAccess
        val Format : TextureFormat
        val ViewDimension : TextureViewDimension
        new (?nextInChain : nativeint, ?access : StorageTextureAccess, ?format : TextureFormat, ?viewDimension : TextureViewDimension) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Access = Option.defaultValue Unchecked.defaultof<StorageTextureAccess> access ; Format = Option.defaultValue Unchecked.defaultof<TextureFormat> format ; ViewDimension = Option.defaultValue Unchecked.defaultof<TextureViewDimension> viewDimension}
    end

///(Managed type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type SurfaceDescriptor =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        [<MarshalAs(UnmanagedType.LPStr)>]
        val Label : string
        new (?nextInChain : nativeint, ?label : string) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Label = Option.defaultValue Unchecked.defaultof<string> label}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type SurfaceDescriptorFromAndroidNativeWindow =
    struct
        val Chain : ChainedStruct
        ///unit byref
        val Window : nativeint
        new (?chain : ChainedStruct, ?window : nativeint) = {Chain = Option.defaultValue Unchecked.defaultof<ChainedStruct> chain ; Window = Option.defaultValue IntPtr.Zero window}
    end

///(Managed type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type SurfaceDescriptorFromCanvasHTMLSelector =
    struct
        val Chain : ChainedStruct
        [<MarshalAs(UnmanagedType.LPStr)>]
        val Selector : string
        new (?chain : ChainedStruct, ?selector : string) = {Chain = Option.defaultValue Unchecked.defaultof<ChainedStruct> chain ; Selector = Option.defaultValue Unchecked.defaultof<string> selector}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type SurfaceDescriptorFromMetalLayer =
    struct
        val Chain : ChainedStruct
        ///unit byref
        val Layer : nativeint
        new (?chain : ChainedStruct, ?layer : nativeint) = {Chain = Option.defaultValue Unchecked.defaultof<ChainedStruct> chain ; Layer = Option.defaultValue IntPtr.Zero layer}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type SurfaceDescriptorFromWaylandSurface =
    struct
        val Chain : ChainedStruct
        ///unit byref
        val Display : nativeint
        ///unit byref
        val Surface : nativeint
        new (?chain : ChainedStruct, ?display : nativeint, ?surface : nativeint) = {Chain = Option.defaultValue Unchecked.defaultof<ChainedStruct> chain ; Display = Option.defaultValue IntPtr.Zero display ; Surface = Option.defaultValue IntPtr.Zero surface}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type SurfaceDescriptorFromWindowsHWND =
    struct
        val Chain : ChainedStruct
        ///unit byref
        val Hinstance : nativeint
        ///unit byref
        val Hwnd : nativeint
        new (?chain : ChainedStruct, ?hinstance : nativeint, ?hwnd : nativeint) = {Chain = Option.defaultValue Unchecked.defaultof<ChainedStruct> chain ; Hinstance = Option.defaultValue IntPtr.Zero hinstance ; Hwnd = Option.defaultValue IntPtr.Zero hwnd}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type SurfaceDescriptorFromXcbWindow =
    struct
        val Chain : ChainedStruct
        ///unit byref
        val Connection : nativeint
        val Window : uint32
        new (?chain : ChainedStruct, ?connection : nativeint, ?window : uint32) = {Chain = Option.defaultValue Unchecked.defaultof<ChainedStruct> chain ; Connection = Option.defaultValue IntPtr.Zero connection ; Window = Option.defaultValue Unchecked.defaultof<uint32> window}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type SurfaceDescriptorFromXlibWindow =
    struct
        val Chain : ChainedStruct
        ///unit byref
        val Display : nativeint
        val Window : uint32
        new (?chain : ChainedStruct, ?display : nativeint, ?window : uint32) = {Chain = Option.defaultValue Unchecked.defaultof<ChainedStruct> chain ; Display = Option.defaultValue IntPtr.Zero display ; Window = Option.defaultValue Unchecked.defaultof<uint32> window}
    end

///(Managed type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type SwapChainDescriptor =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        [<MarshalAs(UnmanagedType.LPStr)>]
        val Label : string
        val Usage : TextureUsage
        val Format : TextureFormat
        val Width : uint32
        val Height : uint32
        val PresentMode : PresentMode
        new (?nextInChain : nativeint, ?label : string, ?usage : TextureUsage, ?format : TextureFormat, ?width : uint32, ?height : uint32, ?presentMode : PresentMode) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Label = Option.defaultValue Unchecked.defaultof<string> label ; Usage = Option.defaultValue Unchecked.defaultof<TextureUsage> usage ; Format = Option.defaultValue Unchecked.defaultof<TextureFormat> format ; Width = Option.defaultValue Unchecked.defaultof<uint32> width ; Height = Option.defaultValue Unchecked.defaultof<uint32> height ; PresentMode = Option.defaultValue Unchecked.defaultof<PresentMode> presentMode}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type TextureBindingLayout =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        val SampleType : TextureSampleType
        val ViewDimension : TextureViewDimension
        [<MarshalAs(UnmanagedType.U1)>]
        val Multisampled : bool
        new (?nextInChain : nativeint, ?sampleType : TextureSampleType, ?viewDimension : TextureViewDimension, ?multisampled : bool) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; SampleType = Option.defaultValue Unchecked.defaultof<TextureSampleType> sampleType ; ViewDimension = Option.defaultValue Unchecked.defaultof<TextureViewDimension> viewDimension ; Multisampled = Option.defaultValue Unchecked.defaultof<bool> multisampled}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type TextureDataLayout =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        val Offset : uint64
        val BytesPerRow : uint32
        val RowsPerImage : uint32
        new (?nextInChain : nativeint, ?offset : uint64, ?bytesPerRow : uint32, ?rowsPerImage : uint32) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Offset = Option.defaultValue Unchecked.defaultof<uint64> offset ; BytesPerRow = Option.defaultValue Unchecked.defaultof<uint32> bytesPerRow ; RowsPerImage = Option.defaultValue Unchecked.defaultof<uint32> rowsPerImage}
    end

///(Managed type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type TextureViewDescriptor =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        [<MarshalAs(UnmanagedType.LPStr)>]
        val Label : string
        val Format : TextureFormat
        val Dimension : TextureViewDimension
        val BaseMipLevel : uint32
        val MipLevelCount : uint32
        val BaseArrayLayer : uint32
        val ArrayLayerCount : uint32
        val Aspect : TextureAspect
        new (?nextInChain : nativeint, ?label : string, ?format : TextureFormat, ?dimension : TextureViewDimension, ?baseMipLevel : uint32, ?mipLevelCount : uint32, ?baseArrayLayer : uint32, ?arrayLayerCount : uint32, ?aspect : TextureAspect) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Label = Option.defaultValue Unchecked.defaultof<string> label ; Format = Option.defaultValue Unchecked.defaultof<TextureFormat> format ; Dimension = Option.defaultValue Unchecked.defaultof<TextureViewDimension> dimension ; BaseMipLevel = Option.defaultValue Unchecked.defaultof<uint32> baseMipLevel ; MipLevelCount = Option.defaultValue Unchecked.defaultof<uint32> mipLevelCount ; BaseArrayLayer = Option.defaultValue Unchecked.defaultof<uint32> baseArrayLayer ; ArrayLayerCount = Option.defaultValue Unchecked.defaultof<uint32> arrayLayerCount ; Aspect = Option.defaultValue Unchecked.defaultof<TextureAspect> aspect}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type VertexAttribute =
    struct
        val Format : VertexFormat
        val Offset : uint64
        val ShaderLocation : uint32
        new (?format : VertexFormat, ?offset : uint64, ?shaderLocation : uint32) = {Format = Option.defaultValue Unchecked.defaultof<VertexFormat> format ; Offset = Option.defaultValue Unchecked.defaultof<uint64> offset ; ShaderLocation = Option.defaultValue Unchecked.defaultof<uint32> shaderLocation}
    end

///(Managed type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type BindGroupDescriptor =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        [<MarshalAs(UnmanagedType.LPStr)>]
        val Label : string
        val Layout : BindGroupLayout
        val EntryCount : uint32
        ///BindGroupEntry inref
        val Entries : nativeint
        new (?nextInChain : nativeint, ?label : string, ?layout : BindGroupLayout, ?entryCount : uint32, ?entries : nativeint) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Label = Option.defaultValue Unchecked.defaultof<string> label ; Layout = Option.defaultValue Unchecked.defaultof<BindGroupLayout> layout ; EntryCount = Option.defaultValue Unchecked.defaultof<uint32> entryCount ; Entries = Option.defaultValue IntPtr.Zero entries}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type BindGroupLayoutEntry =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        val Binding : uint32
        val Visibility : ShaderStage
        val Buffer : BufferBindingLayout
        val Sampler : SamplerBindingLayout
        val Texture : TextureBindingLayout
        val StorageTexture : StorageTextureBindingLayout
        new (?nextInChain : nativeint, ?binding : uint32, ?visibility : ShaderStage, ?buffer : BufferBindingLayout, ?sampler : SamplerBindingLayout, ?texture : TextureBindingLayout, ?storageTexture : StorageTextureBindingLayout) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Binding = Option.defaultValue Unchecked.defaultof<uint32> binding ; Visibility = Option.defaultValue Unchecked.defaultof<ShaderStage> visibility ; Buffer = Option.defaultValue Unchecked.defaultof<BufferBindingLayout> buffer ; Sampler = Option.defaultValue Unchecked.defaultof<SamplerBindingLayout> sampler ; Texture = Option.defaultValue Unchecked.defaultof<TextureBindingLayout> texture ; StorageTexture = Option.defaultValue Unchecked.defaultof<StorageTextureBindingLayout> storageTexture}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type BlendState =
    struct
        val Color : BlendComponent
        val Alpha : BlendComponent
        new (?color : BlendComponent, ?alpha : BlendComponent) = {Color = Option.defaultValue Unchecked.defaultof<BlendComponent> color ; Alpha = Option.defaultValue Unchecked.defaultof<BlendComponent> alpha}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type CompilationInfo =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        val MessageCount : uint32
        ///CompilationMessage inref
        val Messages : nativeint
        new (?nextInChain : nativeint, ?messageCount : uint32, ?messages : nativeint) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; MessageCount = Option.defaultValue Unchecked.defaultof<uint32> messageCount ; Messages = Option.defaultValue IntPtr.Zero messages}
    end

///(Managed type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type ComputePassDescriptor =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        [<MarshalAs(UnmanagedType.LPStr)>]
        val Label : string
        val TimestampWriteCount : uint32
        ///ComputePassTimestampWrite inref
        val TimestampWrites : nativeint
        new (?nextInChain : nativeint, ?label : string, ?timestampWriteCount : uint32, ?timestampWrites : nativeint) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Label = Option.defaultValue Unchecked.defaultof<string> label ; TimestampWriteCount = Option.defaultValue Unchecked.defaultof<uint32> timestampWriteCount ; TimestampWrites = Option.defaultValue IntPtr.Zero timestampWrites}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type DepthStencilState =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        val Format : TextureFormat
        [<MarshalAs(UnmanagedType.U1)>]
        val DepthWriteEnabled : bool
        val DepthCompare : CompareFunction
        val StencilFront : StencilFaceState
        val StencilBack : StencilFaceState
        val StencilReadMask : uint32
        val StencilWriteMask : uint32
        val DepthBias : int32
        val DepthBiasSlopeScale : float
        val DepthBiasClamp : float
        new (?nextInChain : nativeint, ?format : TextureFormat, ?depthWriteEnabled : bool, ?depthCompare : CompareFunction, ?stencilFront : StencilFaceState, ?stencilBack : StencilFaceState, ?stencilReadMask : uint32, ?stencilWriteMask : uint32, ?depthBias : int32, ?depthBiasSlopeScale : float, ?depthBiasClamp : float) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Format = Option.defaultValue Unchecked.defaultof<TextureFormat> format ; DepthWriteEnabled = Option.defaultValue Unchecked.defaultof<bool> depthWriteEnabled ; DepthCompare = Option.defaultValue Unchecked.defaultof<CompareFunction> depthCompare ; StencilFront = Option.defaultValue Unchecked.defaultof<StencilFaceState> stencilFront ; StencilBack = Option.defaultValue Unchecked.defaultof<StencilFaceState> stencilBack ; StencilReadMask = Option.defaultValue Unchecked.defaultof<uint32> stencilReadMask ; StencilWriteMask = Option.defaultValue Unchecked.defaultof<uint32> stencilWriteMask ; DepthBias = Option.defaultValue Unchecked.defaultof<int32> depthBias ; DepthBiasSlopeScale = Option.defaultValue Unchecked.defaultof<float> depthBiasSlopeScale ; DepthBiasClamp = Option.defaultValue Unchecked.defaultof<float> depthBiasClamp}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type ImageCopyBuffer =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        val Layout : TextureDataLayout
        val Buffer : Buffer
        new (?nextInChain : nativeint, ?layout : TextureDataLayout, ?buffer : Buffer) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Layout = Option.defaultValue Unchecked.defaultof<TextureDataLayout> layout ; Buffer = Option.defaultValue Unchecked.defaultof<Buffer> buffer}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type ImageCopyTexture =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        val Texture : Texture
        val MipLevel : uint32
        val Origin : Origin3D
        val Aspect : TextureAspect
        new (?nextInChain : nativeint, ?texture : Texture, ?mipLevel : uint32, ?origin : Origin3D, ?aspect : TextureAspect) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Texture = Option.defaultValue Unchecked.defaultof<Texture> texture ; MipLevel = Option.defaultValue Unchecked.defaultof<uint32> mipLevel ; Origin = Option.defaultValue Unchecked.defaultof<Origin3D> origin ; Aspect = Option.defaultValue Unchecked.defaultof<TextureAspect> aspect}
    end

///(Managed type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type ProgrammableStageDescriptor =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        val Module : ShaderModule
        [<MarshalAs(UnmanagedType.LPStr)>]
        val EntryPoint : string
        val ConstantCount : uint32
        ///ConstantEntry inref
        val Constants : nativeint
        new (?nextInChain : nativeint, ?``module`` : ShaderModule, ?entryPoint : string, ?constantCount : uint32, ?constants : nativeint) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Module = Option.defaultValue Unchecked.defaultof<ShaderModule> ``module`` ; EntryPoint = Option.defaultValue Unchecked.defaultof<string> entryPoint ; ConstantCount = Option.defaultValue Unchecked.defaultof<uint32> constantCount ; Constants = Option.defaultValue IntPtr.Zero constants}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type RenderPassColorAttachment =
    struct
        val View : TextureView
        val ResolveTarget : TextureView
        val LoadOp : LoadOp
        val StoreOp : StoreOp
        val ClearValue : Color
        new (?view : TextureView, ?resolveTarget : TextureView, ?loadOp : LoadOp, ?storeOp : StoreOp, ?clearValue : Color) = {View = Option.defaultValue Unchecked.defaultof<TextureView> view ; ResolveTarget = Option.defaultValue Unchecked.defaultof<TextureView> resolveTarget ; LoadOp = Option.defaultValue Unchecked.defaultof<LoadOp> loadOp ; StoreOp = Option.defaultValue Unchecked.defaultof<StoreOp> storeOp ; ClearValue = Option.defaultValue Unchecked.defaultof<Color> clearValue}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type RequiredLimits =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        val Limits : Limits
        new (?nextInChain : nativeint, ?limits : Limits) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Limits = Option.defaultValue Unchecked.defaultof<Limits> limits}
    end

///(Managed type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type ShaderModuleDescriptor =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        [<MarshalAs(UnmanagedType.LPStr)>]
        val Label : string
        val HintCount : uint32
        ///ShaderModuleCompilationHint inref
        val Hints : nativeint
        new (?nextInChain : nativeint, ?label : string, ?hintCount : uint32, ?hints : nativeint) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Label = Option.defaultValue Unchecked.defaultof<string> label ; HintCount = Option.defaultValue Unchecked.defaultof<uint32> hintCount ; Hints = Option.defaultValue IntPtr.Zero hints}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type SupportedLimits =
    struct
        ///ChainedStructOut byref
        val NextInChain : nativeint
        val Limits : Limits
        new (?nextInChain : nativeint, ?limits : Limits) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Limits = Option.defaultValue Unchecked.defaultof<Limits> limits}
    end

///(Managed type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type TextureDescriptor =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        [<MarshalAs(UnmanagedType.LPStr)>]
        val Label : string
        val Usage : TextureUsage
        val Dimension : TextureDimension
        val Size : Extent3D
        val Format : TextureFormat
        val MipLevelCount : uint32
        val SampleCount : uint32
        val ViewFormatCount : uint32
        ///TextureFormat inref
        val ViewFormats : nativeint
        new (?nextInChain : nativeint, ?label : string, ?usage : TextureUsage, ?dimension : TextureDimension, ?size : Extent3D, ?format : TextureFormat, ?mipLevelCount : uint32, ?sampleCount : uint32, ?viewFormatCount : uint32, ?viewFormats : nativeint) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Label = Option.defaultValue Unchecked.defaultof<string> label ; Usage = Option.defaultValue Unchecked.defaultof<TextureUsage> usage ; Dimension = Option.defaultValue Unchecked.defaultof<TextureDimension> dimension ; Size = Option.defaultValue Unchecked.defaultof<Extent3D> size ; Format = Option.defaultValue Unchecked.defaultof<TextureFormat> format ; MipLevelCount = Option.defaultValue Unchecked.defaultof<uint32> mipLevelCount ; SampleCount = Option.defaultValue Unchecked.defaultof<uint32> sampleCount ; ViewFormatCount = Option.defaultValue Unchecked.defaultof<uint32> viewFormatCount ; ViewFormats = Option.defaultValue IntPtr.Zero viewFormats}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type VertexBufferLayout =
    struct
        val ArrayStride : uint64
        val StepMode : VertexStepMode
        val AttributeCount : uint32
        ///VertexAttribute inref
        val Attributes : nativeint
        new (?arrayStride : uint64, ?stepMode : VertexStepMode, ?attributeCount : uint32, ?attributes : nativeint) = {ArrayStride = Option.defaultValue Unchecked.defaultof<uint64> arrayStride ; StepMode = Option.defaultValue Unchecked.defaultof<VertexStepMode> stepMode ; AttributeCount = Option.defaultValue Unchecked.defaultof<uint32> attributeCount ; Attributes = Option.defaultValue IntPtr.Zero attributes}
    end

///(Managed type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type BindGroupLayoutDescriptor =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        [<MarshalAs(UnmanagedType.LPStr)>]
        val Label : string
        val EntryCount : uint32
        ///BindGroupLayoutEntry inref
        val Entries : nativeint
        new (?nextInChain : nativeint, ?label : string, ?entryCount : uint32, ?entries : nativeint) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Label = Option.defaultValue Unchecked.defaultof<string> label ; EntryCount = Option.defaultValue Unchecked.defaultof<uint32> entryCount ; Entries = Option.defaultValue IntPtr.Zero entries}
    end

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type ColorTargetState =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        val Format : TextureFormat
        ///BlendState inref
        val Blend : nativeint
        val WriteMask : ColorWriteMask
        new (?nextInChain : nativeint, ?format : TextureFormat, ?blend : nativeint, ?writeMask : ColorWriteMask) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Format = Option.defaultValue Unchecked.defaultof<TextureFormat> format ; Blend = Option.defaultValue IntPtr.Zero blend ; WriteMask = Option.defaultValue Unchecked.defaultof<ColorWriteMask> writeMask}
    end

///(Managed type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type ComputePipelineDescriptor =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        [<MarshalAs(UnmanagedType.LPStr)>]
        val Label : string
        val Layout : PipelineLayout
        val Compute : ProgrammableStageDescriptor
        new (?nextInChain : nativeint, ?label : string, ?layout : PipelineLayout, ?compute : ProgrammableStageDescriptor) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Label = Option.defaultValue Unchecked.defaultof<string> label ; Layout = Option.defaultValue Unchecked.defaultof<PipelineLayout> layout ; Compute = Option.defaultValue Unchecked.defaultof<ProgrammableStageDescriptor> compute}
    end

///(Managed type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type DeviceDescriptor =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        [<MarshalAs(UnmanagedType.LPStr)>]
        val Label : string
        val RequiredFeaturesCount : uint32
        ///FeatureName inref
        val RequiredFeatures : nativeint
        ///RequiredLimits inref
        val RequiredLimits : nativeint
        val DefaultQueue : QueueDescriptor
        new (?nextInChain : nativeint, ?label : string, ?requiredFeaturesCount : uint32, ?requiredFeatures : nativeint, ?requiredLimits : nativeint, ?defaultQueue : QueueDescriptor) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Label = Option.defaultValue Unchecked.defaultof<string> label ; RequiredFeaturesCount = Option.defaultValue Unchecked.defaultof<uint32> requiredFeaturesCount ; RequiredFeatures = Option.defaultValue IntPtr.Zero requiredFeatures ; RequiredLimits = Option.defaultValue IntPtr.Zero requiredLimits ; DefaultQueue = Option.defaultValue Unchecked.defaultof<QueueDescriptor> defaultQueue}
    end

///(Managed type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type RenderPassDescriptor =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        [<MarshalAs(UnmanagedType.LPStr)>]
        val Label : string
        val ColorAttachmentCount : uint32
        ///RenderPassColorAttachment inref
        val ColorAttachments : nativeint
        ///RenderPassDepthStencilAttachment inref
        val DepthStencilAttachment : nativeint
        val OcclusionQuerySet : QuerySet
        val TimestampWriteCount : uint32
        ///RenderPassTimestampWrite inref
        val TimestampWrites : nativeint
        new (?nextInChain : nativeint, ?label : string, ?colorAttachmentCount : uint32, ?colorAttachments : nativeint, ?depthStencilAttachment : nativeint, ?occlusionQuerySet : QuerySet, ?timestampWriteCount : uint32, ?timestampWrites : nativeint) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Label = Option.defaultValue Unchecked.defaultof<string> label ; ColorAttachmentCount = Option.defaultValue Unchecked.defaultof<uint32> colorAttachmentCount ; ColorAttachments = Option.defaultValue IntPtr.Zero colorAttachments ; DepthStencilAttachment = Option.defaultValue IntPtr.Zero depthStencilAttachment ; OcclusionQuerySet = Option.defaultValue Unchecked.defaultof<QuerySet> occlusionQuerySet ; TimestampWriteCount = Option.defaultValue Unchecked.defaultof<uint32> timestampWriteCount ; TimestampWrites = Option.defaultValue IntPtr.Zero timestampWrites}
    end

///(Managed type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type VertexState =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        val Module : ShaderModule
        [<MarshalAs(UnmanagedType.LPStr)>]
        val EntryPoint : string
        val ConstantCount : uint32
        ///ConstantEntry inref
        val Constants : nativeint
        val BufferCount : uint32
        ///VertexBufferLayout inref
        val Buffers : nativeint
        new (?nextInChain : nativeint, ?``module`` : ShaderModule, ?entryPoint : string, ?constantCount : uint32, ?constants : nativeint, ?bufferCount : uint32, ?buffers : nativeint) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Module = Option.defaultValue Unchecked.defaultof<ShaderModule> ``module`` ; EntryPoint = Option.defaultValue Unchecked.defaultof<string> entryPoint ; ConstantCount = Option.defaultValue Unchecked.defaultof<uint32> constantCount ; Constants = Option.defaultValue IntPtr.Zero constants ; BufferCount = Option.defaultValue Unchecked.defaultof<uint32> bufferCount ; Buffers = Option.defaultValue IntPtr.Zero buffers}
    end

///(Managed type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type FragmentState =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        val Module : ShaderModule
        [<MarshalAs(UnmanagedType.LPStr)>]
        val EntryPoint : string
        val ConstantCount : uint32
        ///ConstantEntry inref
        val Constants : nativeint
        val TargetCount : uint32
        ///ColorTargetState inref
        val Targets : nativeint
        new (?nextInChain : nativeint, ?``module`` : ShaderModule, ?entryPoint : string, ?constantCount : uint32, ?constants : nativeint, ?targetCount : uint32, ?targets : nativeint) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Module = Option.defaultValue Unchecked.defaultof<ShaderModule> ``module`` ; EntryPoint = Option.defaultValue Unchecked.defaultof<string> entryPoint ; ConstantCount = Option.defaultValue Unchecked.defaultof<uint32> constantCount ; Constants = Option.defaultValue IntPtr.Zero constants ; TargetCount = Option.defaultValue Unchecked.defaultof<uint32> targetCount ; Targets = Option.defaultValue IntPtr.Zero targets}
    end

///(Managed type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type RenderPipelineDescriptor =
    struct
        ///ChainedStruct inref
        val NextInChain : nativeint
        [<MarshalAs(UnmanagedType.LPStr)>]
        val Label : string
        val Layout : PipelineLayout
        val Vertex : VertexState
        val Primitive : PrimitiveState
        ///DepthStencilState inref
        val DepthStencil : nativeint
        val Multisample : MultisampleState
        ///FragmentState inref
        val Fragment : nativeint
        new (?nextInChain : nativeint, ?label : string, ?layout : PipelineLayout, ?vertex : VertexState, ?primitive : PrimitiveState, ?depthStencil : nativeint, ?multisample : MultisampleState, ?fragment : nativeint) = {NextInChain = Option.defaultValue IntPtr.Zero nextInChain ; Label = Option.defaultValue Unchecked.defaultof<string> label ; Layout = Option.defaultValue Unchecked.defaultof<PipelineLayout> layout ; Vertex = Option.defaultValue Unchecked.defaultof<VertexState> vertex ; Primitive = Option.defaultValue Unchecked.defaultof<PrimitiveState> primitive ; DepthStencil = Option.defaultValue IntPtr.Zero depthStencil ; Multisample = Option.defaultValue Unchecked.defaultof<MultisampleState> multisample ; Fragment = Option.defaultValue IntPtr.Zero fragment}
    end

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type BufferMapCallback
    = delegate of
         status:BufferMapAsyncStatus
         *  userdata:nativeint
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type CompilationInfoCallback
    = delegate of
         status:CompilationInfoRequestStatus
         *  compilationInfo:CompilationInfo inref
         *  userdata:nativeint
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type CreateComputePipelineAsyncCallback
    = delegate of
         status:CreatePipelineAsyncStatus
         *  pipeline:ComputePipeline
         * [<MarshalAs(UnmanagedType.LPStr)>] message:string
         *  userdata:nativeint
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type CreateRenderPipelineAsyncCallback
    = delegate of
         status:CreatePipelineAsyncStatus
         *  pipeline:RenderPipeline
         * [<MarshalAs(UnmanagedType.LPStr)>] message:string
         *  userdata:nativeint
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type DeviceLostCallback
    = delegate of
         reason:DeviceLostReason
         * [<MarshalAs(UnmanagedType.LPStr)>] message:string
         *  userdata:nativeint
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type ErrorCallback
    = delegate of
         ``type``:ErrorType
         * [<MarshalAs(UnmanagedType.LPStr)>] message:string
         *  userdata:nativeint
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type Proc
    = delegate of
        unit
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type QueueWorkDoneCallback
    = delegate of
         status:QueueWorkDoneStatus
         *  userdata:nativeint
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RequestAdapterCallback
    = delegate of
         status:RequestAdapterStatus
         *  adapter:Adapter
         * [<MarshalAs(UnmanagedType.LPStr)>] message:string
         *  userdata:nativeint
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RequestDeviceCallback
    = delegate of
         status:RequestDeviceStatus
         *  device:Device
         * [<MarshalAs(UnmanagedType.LPStr)>] message:string
         *  userdata:nativeint
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type CreateInstance
    = delegate of
         descriptor:InstanceDescriptor inref
          -> Instance

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type GetProcAddress
    = delegate of
         device:Device
         * [<MarshalAs(UnmanagedType.LPStr)>] procName:string
          -> Proc

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type AdapterEnumerateFeatures
    = delegate of
         adapter:Adapter
         *  features:FeatureName byref
          -> uint64

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type AdapterGetLimits
    = delegate of
         adapter:Adapter
         *  limits:SupportedLimits byref
          -> bool

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type AdapterGetProperties
    = delegate of
         adapter:Adapter
         *  properties:AdapterProperties byref
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type AdapterHasFeature
    = delegate of
         adapter:Adapter
         *  feature:FeatureName
          -> bool

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type AdapterRequestDevice
    = delegate of
         adapter:Adapter
         *  descriptor:DeviceDescriptor inref
         *  callback:RequestDeviceCallback
         *  userdata:nativeint
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type BufferDestroy
    = delegate of
         buffer:Buffer
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type BufferGetConstMappedRange
    = delegate of
         buffer:Buffer
         *  offset:uint64
         *  size:uint64
          -> nativeint

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type BufferGetMappedRange
    = delegate of
         buffer:Buffer
         *  offset:uint64
         *  size:uint64
          -> nativeint

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type BufferMapAsync
    = delegate of
         buffer:Buffer
         *  mode:MapMode
         *  offset:uint64
         *  size:uint64
         *  callback:BufferMapCallback
         *  userdata:nativeint
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type BufferUnmap
    = delegate of
         buffer:Buffer
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type CommandEncoderBeginComputePass
    = delegate of
         commandEncoder:CommandEncoder
         *  descriptor:ComputePassDescriptor inref
          -> ComputePassEncoder

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type CommandEncoderBeginRenderPass
    = delegate of
         commandEncoder:CommandEncoder
         *  descriptor:RenderPassDescriptor inref
          -> RenderPassEncoder

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type CommandEncoderClearBuffer
    = delegate of
         commandEncoder:CommandEncoder
         *  buffer:Buffer
         *  offset:uint64
         *  size:uint64
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type CommandEncoderCopyBufferToBuffer
    = delegate of
         commandEncoder:CommandEncoder
         *  source:Buffer
         *  sourceOffset:uint64
         *  destination:Buffer
         *  destinationOffset:uint64
         *  size:uint64
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type CommandEncoderCopyBufferToTexture
    = delegate of
         commandEncoder:CommandEncoder
         *  source:ImageCopyBuffer inref
         *  destination:ImageCopyTexture inref
         *  copySize:Extent3D inref
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type CommandEncoderCopyTextureToBuffer
    = delegate of
         commandEncoder:CommandEncoder
         *  source:ImageCopyTexture inref
         *  destination:ImageCopyBuffer inref
         *  copySize:Extent3D inref
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type CommandEncoderCopyTextureToTexture
    = delegate of
         commandEncoder:CommandEncoder
         *  source:ImageCopyTexture inref
         *  destination:ImageCopyTexture inref
         *  copySize:Extent3D inref
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type CommandEncoderFinish
    = delegate of
         commandEncoder:CommandEncoder
         *  descriptor:CommandBufferDescriptor inref
          -> CommandBuffer

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type CommandEncoderInsertDebugMarker
    = delegate of
         commandEncoder:CommandEncoder
         * [<MarshalAs(UnmanagedType.LPStr)>] markerLabel:string
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type CommandEncoderPopDebugGroup
    = delegate of
         commandEncoder:CommandEncoder
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type CommandEncoderPushDebugGroup
    = delegate of
         commandEncoder:CommandEncoder
         * [<MarshalAs(UnmanagedType.LPStr)>] groupLabel:string
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type CommandEncoderResolveQuerySet
    = delegate of
         commandEncoder:CommandEncoder
         *  querySet:QuerySet
         *  firstQuery:uint32
         *  queryCount:uint32
         *  destination:Buffer
         *  destinationOffset:uint64
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type CommandEncoderWriteTimestamp
    = delegate of
         commandEncoder:CommandEncoder
         *  querySet:QuerySet
         *  queryIndex:uint32
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type ComputePassEncoderBeginPipelineStatisticsQuery
    = delegate of
         computePassEncoder:ComputePassEncoder
         *  querySet:QuerySet
         *  queryIndex:uint32
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type ComputePassEncoderDispatch
    = delegate of
         computePassEncoder:ComputePassEncoder
         *  workgroupCountX:uint32
         *  workgroupCountY:uint32
         *  workgroupCountZ:uint32
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type ComputePassEncoderDispatchIndirect
    = delegate of
         computePassEncoder:ComputePassEncoder
         *  indirectBuffer:Buffer
         *  indirectOffset:uint64
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type ComputePassEncoderEnd
    = delegate of
         computePassEncoder:ComputePassEncoder
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type ComputePassEncoderEndPipelineStatisticsQuery
    = delegate of
         computePassEncoder:ComputePassEncoder
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type ComputePassEncoderInsertDebugMarker
    = delegate of
         computePassEncoder:ComputePassEncoder
         * [<MarshalAs(UnmanagedType.LPStr)>] markerLabel:string
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type ComputePassEncoderPopDebugGroup
    = delegate of
         computePassEncoder:ComputePassEncoder
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type ComputePassEncoderPushDebugGroup
    = delegate of
         computePassEncoder:ComputePassEncoder
         * [<MarshalAs(UnmanagedType.LPStr)>] groupLabel:string
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type ComputePassEncoderSetBindGroup
    = delegate of
         computePassEncoder:ComputePassEncoder
         *  groupIndex:uint32
         *  group:BindGroup
         *  dynamicOffsetCount:uint32
         *  dynamicOffsets:uint32 inref
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type ComputePassEncoderSetPipeline
    = delegate of
         computePassEncoder:ComputePassEncoder
         *  pipeline:ComputePipeline
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type ComputePipelineGetBindGroupLayout
    = delegate of
         computePipeline:ComputePipeline
         *  groupIndex:uint32
          -> BindGroupLayout

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type ComputePipelineSetLabel
    = delegate of
         computePipeline:ComputePipeline
         * [<MarshalAs(UnmanagedType.LPStr)>] label:string
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type DeviceCreateBindGroup
    = delegate of
         device:Device
         *  descriptor:BindGroupDescriptor inref
          -> BindGroup

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type DeviceCreateBindGroupLayout
    = delegate of
         device:Device
         *  descriptor:BindGroupLayoutDescriptor inref
          -> BindGroupLayout

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type DeviceCreateBuffer
    = delegate of
         device:Device
         *  descriptor:BufferDescriptor inref
          -> Buffer

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type DeviceCreateCommandEncoder
    = delegate of
         device:Device
         *  descriptor:CommandEncoderDescriptor inref
          -> CommandEncoder

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type DeviceCreateComputePipeline
    = delegate of
         device:Device
         *  descriptor:ComputePipelineDescriptor inref
          -> ComputePipeline

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type DeviceCreateComputePipelineAsync
    = delegate of
         device:Device
         *  descriptor:ComputePipelineDescriptor inref
         *  callback:CreateComputePipelineAsyncCallback
         *  userdata:nativeint
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type DeviceCreatePipelineLayout
    = delegate of
         device:Device
         *  descriptor:PipelineLayoutDescriptor inref
          -> PipelineLayout

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type DeviceCreateQuerySet
    = delegate of
         device:Device
         *  descriptor:QuerySetDescriptor inref
          -> QuerySet

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type DeviceCreateRenderBundleEncoder
    = delegate of
         device:Device
         *  descriptor:RenderBundleEncoderDescriptor inref
          -> RenderBundleEncoder

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type DeviceCreateRenderPipeline
    = delegate of
         device:Device
         *  descriptor:RenderPipelineDescriptor inref
          -> RenderPipeline

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type DeviceCreateRenderPipelineAsync
    = delegate of
         device:Device
         *  descriptor:RenderPipelineDescriptor inref
         *  callback:CreateRenderPipelineAsyncCallback
         *  userdata:nativeint
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type DeviceCreateSampler
    = delegate of
         device:Device
         *  descriptor:SamplerDescriptor inref
          -> Sampler

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type DeviceCreateShaderModule
    = delegate of
         device:Device
         *  descriptor:ShaderModuleDescriptor inref
          -> ShaderModule

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type DeviceCreateSwapChain
    = delegate of
         device:Device
         *  surface:Surface
         *  descriptor:SwapChainDescriptor inref
          -> SwapChain

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type DeviceCreateTexture
    = delegate of
         device:Device
         *  descriptor:TextureDescriptor inref
          -> Texture

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type DeviceDestroy
    = delegate of
         device:Device
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type DeviceEnumerateFeatures
    = delegate of
         device:Device
         *  features:FeatureName byref
          -> uint64

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type DeviceGetLimits
    = delegate of
         device:Device
         *  limits:SupportedLimits byref
          -> bool

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type DeviceGetQueue
    = delegate of
         device:Device
          -> Queue

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type DeviceHasFeature
    = delegate of
         device:Device
         *  feature:FeatureName
          -> bool

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type DevicePopErrorScope
    = delegate of
         device:Device
         *  callback:ErrorCallback
         *  userdata:nativeint
          -> bool

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type DevicePushErrorScope
    = delegate of
         device:Device
         *  filter:ErrorFilter
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type DeviceSetDeviceLostCallback
    = delegate of
         device:Device
         *  callback:DeviceLostCallback
         *  userdata:nativeint
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type DeviceSetUncapturedErrorCallback
    = delegate of
         device:Device
         *  callback:ErrorCallback
         *  userdata:nativeint
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type InstanceCreateSurface
    = delegate of
         instance:Instance
         *  descriptor:SurfaceDescriptor inref
          -> Surface

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type InstanceProcessEvents
    = delegate of
         instance:Instance
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type InstanceRequestAdapter
    = delegate of
         instance:Instance
         *  options:RequestAdapterOptions inref
         *  callback:RequestAdapterCallback
         *  userdata:nativeint
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type QuerySetDestroy
    = delegate of
         querySet:QuerySet
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type QueueOnSubmittedWorkDone
    = delegate of
         queue:Queue
         *  callback:QueueWorkDoneCallback
         *  userdata:nativeint
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type QueueSubmit
    = delegate of
         queue:Queue
         *  commandCount:uint32
         *  commands:CommandBuffer inref
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type QueueWriteBuffer
    = delegate of
         queue:Queue
         *  buffer:Buffer
         *  bufferOffset:uint64
         *  data:nativeint
         *  size:uint64
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type QueueWriteTexture
    = delegate of
         queue:Queue
         *  destination:ImageCopyTexture inref
         *  data:nativeint
         *  dataSize:uint64
         *  dataLayout:TextureDataLayout inref
         *  writeSize:Extent3D inref
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RenderBundleEncoderDraw
    = delegate of
         renderBundleEncoder:RenderBundleEncoder
         *  vertexCount:uint32
         *  instanceCount:uint32
         *  firstVertex:uint32
         *  firstInstance:uint32
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RenderBundleEncoderDrawIndexed
    = delegate of
         renderBundleEncoder:RenderBundleEncoder
         *  indexCount:uint32
         *  instanceCount:uint32
         *  firstIndex:uint32
         *  baseVertex:int32
         *  firstInstance:uint32
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RenderBundleEncoderDrawIndexedIndirect
    = delegate of
         renderBundleEncoder:RenderBundleEncoder
         *  indirectBuffer:Buffer
         *  indirectOffset:uint64
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RenderBundleEncoderDrawIndirect
    = delegate of
         renderBundleEncoder:RenderBundleEncoder
         *  indirectBuffer:Buffer
         *  indirectOffset:uint64
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RenderBundleEncoderFinish
    = delegate of
         renderBundleEncoder:RenderBundleEncoder
         *  descriptor:RenderBundleDescriptor inref
          -> RenderBundle

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RenderBundleEncoderInsertDebugMarker
    = delegate of
         renderBundleEncoder:RenderBundleEncoder
         * [<MarshalAs(UnmanagedType.LPStr)>] markerLabel:string
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RenderBundleEncoderPopDebugGroup
    = delegate of
         renderBundleEncoder:RenderBundleEncoder
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RenderBundleEncoderPushDebugGroup
    = delegate of
         renderBundleEncoder:RenderBundleEncoder
         * [<MarshalAs(UnmanagedType.LPStr)>] groupLabel:string
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RenderBundleEncoderSetBindGroup
    = delegate of
         renderBundleEncoder:RenderBundleEncoder
         *  groupIndex:uint32
         *  group:BindGroup
         *  dynamicOffsetCount:uint32
         *  dynamicOffsets:uint32 inref
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RenderBundleEncoderSetIndexBuffer
    = delegate of
         renderBundleEncoder:RenderBundleEncoder
         *  buffer:Buffer
         *  format:IndexFormat
         *  offset:uint64
         *  size:uint64
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RenderBundleEncoderSetPipeline
    = delegate of
         renderBundleEncoder:RenderBundleEncoder
         *  pipeline:RenderPipeline
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RenderBundleEncoderSetVertexBuffer
    = delegate of
         renderBundleEncoder:RenderBundleEncoder
         *  slot:uint32
         *  buffer:Buffer
         *  offset:uint64
         *  size:uint64
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RenderPassEncoderBeginOcclusionQuery
    = delegate of
         renderPassEncoder:RenderPassEncoder
         *  queryIndex:uint32
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RenderPassEncoderBeginPipelineStatisticsQuery
    = delegate of
         renderPassEncoder:RenderPassEncoder
         *  querySet:QuerySet
         *  queryIndex:uint32
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RenderPassEncoderDraw
    = delegate of
         renderPassEncoder:RenderPassEncoder
         *  vertexCount:uint32
         *  instanceCount:uint32
         *  firstVertex:uint32
         *  firstInstance:uint32
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RenderPassEncoderDrawIndexed
    = delegate of
         renderPassEncoder:RenderPassEncoder
         *  indexCount:uint32
         *  instanceCount:uint32
         *  firstIndex:uint32
         *  baseVertex:int32
         *  firstInstance:uint32
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RenderPassEncoderDrawIndexedIndirect
    = delegate of
         renderPassEncoder:RenderPassEncoder
         *  indirectBuffer:Buffer
         *  indirectOffset:uint64
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RenderPassEncoderDrawIndirect
    = delegate of
         renderPassEncoder:RenderPassEncoder
         *  indirectBuffer:Buffer
         *  indirectOffset:uint64
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RenderPassEncoderEnd
    = delegate of
         renderPassEncoder:RenderPassEncoder
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RenderPassEncoderEndOcclusionQuery
    = delegate of
         renderPassEncoder:RenderPassEncoder
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RenderPassEncoderEndPipelineStatisticsQuery
    = delegate of
         renderPassEncoder:RenderPassEncoder
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RenderPassEncoderExecuteBundles
    = delegate of
         renderPassEncoder:RenderPassEncoder
         *  bundlesCount:uint32
         *  bundles:RenderBundle inref
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RenderPassEncoderInsertDebugMarker
    = delegate of
         renderPassEncoder:RenderPassEncoder
         * [<MarshalAs(UnmanagedType.LPStr)>] markerLabel:string
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RenderPassEncoderPopDebugGroup
    = delegate of
         renderPassEncoder:RenderPassEncoder
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RenderPassEncoderPushDebugGroup
    = delegate of
         renderPassEncoder:RenderPassEncoder
         * [<MarshalAs(UnmanagedType.LPStr)>] groupLabel:string
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RenderPassEncoderSetBindGroup
    = delegate of
         renderPassEncoder:RenderPassEncoder
         *  groupIndex:uint32
         *  group:BindGroup
         *  dynamicOffsetCount:uint32
         *  dynamicOffsets:uint32 inref
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RenderPassEncoderSetBlendConstant
    = delegate of
         renderPassEncoder:RenderPassEncoder
         *  color:Color inref
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RenderPassEncoderSetIndexBuffer
    = delegate of
         renderPassEncoder:RenderPassEncoder
         *  buffer:Buffer
         *  format:IndexFormat
         *  offset:uint64
         *  size:uint64
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RenderPassEncoderSetPipeline
    = delegate of
         renderPassEncoder:RenderPassEncoder
         *  pipeline:RenderPipeline
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RenderPassEncoderSetScissorRect
    = delegate of
         renderPassEncoder:RenderPassEncoder
         *  x:uint32
         *  y:uint32
         *  width:uint32
         *  height:uint32
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RenderPassEncoderSetStencilReference
    = delegate of
         renderPassEncoder:RenderPassEncoder
         *  reference:uint32
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RenderPassEncoderSetVertexBuffer
    = delegate of
         renderPassEncoder:RenderPassEncoder
         *  slot:uint32
         *  buffer:Buffer
         *  offset:uint64
         *  size:uint64
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RenderPassEncoderSetViewport
    = delegate of
         renderPassEncoder:RenderPassEncoder
         *  x:float
         *  y:float
         *  width:float
         *  height:float
         *  minDepth:float
         *  maxDepth:float
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RenderPipelineGetBindGroupLayout
    = delegate of
         renderPipeline:RenderPipeline
         *  groupIndex:uint32
          -> BindGroupLayout

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type RenderPipelineSetLabel
    = delegate of
         renderPipeline:RenderPipeline
         * [<MarshalAs(UnmanagedType.LPStr)>] label:string
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type ShaderModuleGetCompilationInfo
    = delegate of
         shaderModule:ShaderModule
         *  callback:CompilationInfoCallback
         *  userdata:nativeint
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type ShaderModuleSetLabel
    = delegate of
         shaderModule:ShaderModule
         * [<MarshalAs(UnmanagedType.LPStr)>] label:string
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type SurfaceGetPreferredFormat
    = delegate of
         surface:Surface
         *  adapter:Adapter
          -> TextureFormat

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type SwapChainGetCurrentTextureView
    = delegate of
         swapChain:SwapChain
          -> TextureView

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type SwapChainPresent
    = delegate of
         swapChain:SwapChain
          -> unit

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type TextureCreateView
    = delegate of
         texture:Texture
         *  descriptor:TextureViewDescriptor inref
          -> TextureView

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type TextureDestroy
    = delegate of
         texture:Texture
          -> unit

[<DllImport("libwgpu",
        EntryPoint = "wgpuCreateInstance",
        CallingConvention = CallingConvention.Cdecl)>]
extern Instance wgpuCreateInstance([<In>] InstanceDescriptor* descriptor)

[<DllImport("libwgpu",
        EntryPoint = "wgpuGetProcAddress",
        CallingConvention = CallingConvention.Cdecl)>]
extern Proc wgpuGetProcAddress( Device device, [<MarshalAs(UnmanagedType.LPStr)>] string procName)

[<DllImport("libwgpu",
        EntryPoint = "wgpuAdapterEnumerateFeatures",
        CallingConvention = CallingConvention.Cdecl)>]
extern uint64 wgpuAdapterEnumerateFeatures( Adapter adapter, [<In ; Out>] FeatureName* features)

[<DllImport("libwgpu",
        EntryPoint = "wgpuAdapterGetLimits",
        CallingConvention = CallingConvention.Cdecl)>]
extern bool wgpuAdapterGetLimits( Adapter adapter, [<In ; Out>] SupportedLimits* limits)

[<DllImport("libwgpu",
        EntryPoint = "wgpuAdapterGetProperties",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuAdapterGetProperties( Adapter adapter, [<In ; Out>] AdapterProperties& properties)

[<DllImport("libwgpu",
        EntryPoint = "wgpuAdapterHasFeature",
        CallingConvention = CallingConvention.Cdecl)>]
extern bool wgpuAdapterHasFeature( Adapter adapter,  FeatureName feature)

[<DllImport("libwgpu",
        EntryPoint = "wgpuAdapterRequestDevice",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuAdapterRequestDevice( Adapter adapter, [<In>] DeviceDescriptor& descriptor,  RequestDeviceCallback callback,  nativeint userdata)

[<DllImport("libwgpu",
        EntryPoint = "wgpuBufferDestroy",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuBufferDestroy( Buffer buffer)

[<DllImport("libwgpu",
        EntryPoint = "wgpuBufferGetConstMappedRange",
        CallingConvention = CallingConvention.Cdecl)>]
extern nativeint wgpuBufferGetConstMappedRange( Buffer buffer,  uint64 offset,  uint64 size)

[<DllImport("libwgpu",
        EntryPoint = "wgpuBufferGetMappedRange",
        CallingConvention = CallingConvention.Cdecl)>]
extern nativeint wgpuBufferGetMappedRange( Buffer buffer,  uint64 offset,  uint64 size)

[<DllImport("libwgpu",
        EntryPoint = "wgpuBufferMapAsync",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuBufferMapAsync( Buffer buffer,  MapMode mode,  uint64 offset,  uint64 size,  BufferMapCallback callback,  nativeint userdata)

[<DllImport("libwgpu",
        EntryPoint = "wgpuBufferUnmap",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuBufferUnmap( Buffer buffer)

[<DllImport("libwgpu",
        EntryPoint = "wgpuCommandEncoderBeginComputePass",
        CallingConvention = CallingConvention.Cdecl)>]
extern ComputePassEncoder wgpuCommandEncoderBeginComputePass( CommandEncoder commandEncoder, [<In>] ComputePassDescriptor& descriptor)

[<DllImport("libwgpu",
        EntryPoint = "wgpuCommandEncoderBeginRenderPass",
        CallingConvention = CallingConvention.Cdecl)>]
extern RenderPassEncoder wgpuCommandEncoderBeginRenderPass( CommandEncoder commandEncoder, [<In>] RenderPassDescriptor& descriptor)

[<DllImport("libwgpu",
        EntryPoint = "wgpuCommandEncoderClearBuffer",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuCommandEncoderClearBuffer( CommandEncoder commandEncoder,  Buffer buffer,  uint64 offset,  uint64 size)

[<DllImport("libwgpu",
        EntryPoint = "wgpuCommandEncoderCopyBufferToBuffer",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuCommandEncoderCopyBufferToBuffer( CommandEncoder commandEncoder,  Buffer source,  uint64 sourceOffset,  Buffer destination,  uint64 destinationOffset,  uint64 size)

[<DllImport("libwgpu",
        EntryPoint = "wgpuCommandEncoderCopyBufferToTexture",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuCommandEncoderCopyBufferToTexture( CommandEncoder commandEncoder, [<In>] ImageCopyBuffer* source, [<In>] ImageCopyTexture* destination, [<In>] Extent3D* copySize)

[<DllImport("libwgpu",
        EntryPoint = "wgpuCommandEncoderCopyTextureToBuffer",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuCommandEncoderCopyTextureToBuffer( CommandEncoder commandEncoder, [<In>] ImageCopyTexture* source, [<In>] ImageCopyBuffer* destination, [<In>] Extent3D* copySize)

[<DllImport("libwgpu",
        EntryPoint = "wgpuCommandEncoderCopyTextureToTexture",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuCommandEncoderCopyTextureToTexture( CommandEncoder commandEncoder, [<In>] ImageCopyTexture* source, [<In>] ImageCopyTexture* destination, [<In>] Extent3D* copySize)

[<DllImport("libwgpu",
        EntryPoint = "wgpuCommandEncoderFinish",
        CallingConvention = CallingConvention.Cdecl)>]
extern CommandBuffer wgpuCommandEncoderFinish( CommandEncoder commandEncoder, [<In>] CommandBufferDescriptor& descriptor)

[<DllImport("libwgpu",
        EntryPoint = "wgpuCommandEncoderInsertDebugMarker",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuCommandEncoderInsertDebugMarker( CommandEncoder commandEncoder, [<MarshalAs(UnmanagedType.LPStr)>] string markerLabel)

[<DllImport("libwgpu",
        EntryPoint = "wgpuCommandEncoderPopDebugGroup",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuCommandEncoderPopDebugGroup( CommandEncoder commandEncoder)

[<DllImport("libwgpu",
        EntryPoint = "wgpuCommandEncoderPushDebugGroup",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuCommandEncoderPushDebugGroup( CommandEncoder commandEncoder, [<MarshalAs(UnmanagedType.LPStr)>] string groupLabel)

[<DllImport("libwgpu",
        EntryPoint = "wgpuCommandEncoderResolveQuerySet",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuCommandEncoderResolveQuerySet( CommandEncoder commandEncoder,  QuerySet querySet,  uint32 firstQuery,  uint32 queryCount,  Buffer destination,  uint64 destinationOffset)

[<DllImport("libwgpu",
        EntryPoint = "wgpuCommandEncoderWriteTimestamp",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuCommandEncoderWriteTimestamp( CommandEncoder commandEncoder,  QuerySet querySet,  uint32 queryIndex)

[<DllImport("libwgpu",
        EntryPoint = "wgpuComputePassEncoderBeginPipelineStatisticsQuery",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuComputePassEncoderBeginPipelineStatisticsQuery( ComputePassEncoder computePassEncoder,  QuerySet querySet,  uint32 queryIndex)

[<DllImport("libwgpu",
        EntryPoint = "wgpuComputePassEncoderDispatch",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuComputePassEncoderDispatch( ComputePassEncoder computePassEncoder,  uint32 workgroupCountX,  uint32 workgroupCountY,  uint32 workgroupCountZ)

[<DllImport("libwgpu",
        EntryPoint = "wgpuComputePassEncoderDispatchIndirect",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuComputePassEncoderDispatchIndirect( ComputePassEncoder computePassEncoder,  Buffer indirectBuffer,  uint64 indirectOffset)

[<DllImport("libwgpu",
        EntryPoint = "wgpuComputePassEncoderEnd",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuComputePassEncoderEnd( ComputePassEncoder computePassEncoder)

[<DllImport("libwgpu",
        EntryPoint = "wgpuComputePassEncoderEndPipelineStatisticsQuery",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuComputePassEncoderEndPipelineStatisticsQuery( ComputePassEncoder computePassEncoder)

[<DllImport("libwgpu",
        EntryPoint = "wgpuComputePassEncoderInsertDebugMarker",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuComputePassEncoderInsertDebugMarker( ComputePassEncoder computePassEncoder, [<MarshalAs(UnmanagedType.LPStr)>] string markerLabel)

[<DllImport("libwgpu",
        EntryPoint = "wgpuComputePassEncoderPopDebugGroup",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuComputePassEncoderPopDebugGroup( ComputePassEncoder computePassEncoder)

[<DllImport("libwgpu",
        EntryPoint = "wgpuComputePassEncoderPushDebugGroup",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuComputePassEncoderPushDebugGroup( ComputePassEncoder computePassEncoder, [<MarshalAs(UnmanagedType.LPStr)>] string groupLabel)

[<DllImport("libwgpu",
        EntryPoint = "wgpuComputePassEncoderSetBindGroup",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuComputePassEncoderSetBindGroup( ComputePassEncoder computePassEncoder,  uint32 groupIndex,  BindGroup group,  uint32 dynamicOffsetCount, [<In>] uint32* dynamicOffsets)

[<DllImport("libwgpu",
        EntryPoint = "wgpuComputePassEncoderSetPipeline",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuComputePassEncoderSetPipeline( ComputePassEncoder computePassEncoder,  ComputePipeline pipeline)

[<DllImport("libwgpu",
        EntryPoint = "wgpuComputePipelineGetBindGroupLayout",
        CallingConvention = CallingConvention.Cdecl)>]
extern BindGroupLayout wgpuComputePipelineGetBindGroupLayout( ComputePipeline computePipeline,  uint32 groupIndex)

[<DllImport("libwgpu",
        EntryPoint = "wgpuComputePipelineSetLabel",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuComputePipelineSetLabel( ComputePipeline computePipeline, [<MarshalAs(UnmanagedType.LPStr)>] string label)

[<DllImport("libwgpu",
        EntryPoint = "wgpuDeviceCreateBindGroup",
        CallingConvention = CallingConvention.Cdecl)>]
extern BindGroup wgpuDeviceCreateBindGroup( Device device, [<In>] BindGroupDescriptor& descriptor)

[<DllImport("libwgpu",
        EntryPoint = "wgpuDeviceCreateBindGroupLayout",
        CallingConvention = CallingConvention.Cdecl)>]
extern BindGroupLayout wgpuDeviceCreateBindGroupLayout( Device device, [<In>] BindGroupLayoutDescriptor& descriptor)

[<DllImport("libwgpu",
        EntryPoint = "wgpuDeviceCreateBuffer",
        CallingConvention = CallingConvention.Cdecl)>]
extern Buffer wgpuDeviceCreateBuffer( Device device, [<In>] BufferDescriptor& descriptor)

[<DllImport("libwgpu",
        EntryPoint = "wgpuDeviceCreateCommandEncoder",
        CallingConvention = CallingConvention.Cdecl)>]
extern CommandEncoder wgpuDeviceCreateCommandEncoder( Device device, [<In>] CommandEncoderDescriptor& descriptor)

[<DllImport("libwgpu",
        EntryPoint = "wgpuDeviceCreateComputePipeline",
        CallingConvention = CallingConvention.Cdecl)>]
extern ComputePipeline wgpuDeviceCreateComputePipeline( Device device, [<In>] ComputePipelineDescriptor& descriptor)

[<DllImport("libwgpu",
        EntryPoint = "wgpuDeviceCreateComputePipelineAsync",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuDeviceCreateComputePipelineAsync( Device device, [<In>] ComputePipelineDescriptor& descriptor,  CreateComputePipelineAsyncCallback callback,  nativeint userdata)

[<DllImport("libwgpu",
        EntryPoint = "wgpuDeviceCreatePipelineLayout",
        CallingConvention = CallingConvention.Cdecl)>]
extern PipelineLayout wgpuDeviceCreatePipelineLayout( Device device, [<In>] PipelineLayoutDescriptor& descriptor)

[<DllImport("libwgpu",
        EntryPoint = "wgpuDeviceCreateQuerySet",
        CallingConvention = CallingConvention.Cdecl)>]
extern QuerySet wgpuDeviceCreateQuerySet( Device device, [<In>] QuerySetDescriptor& descriptor)

[<DllImport("libwgpu",
        EntryPoint = "wgpuDeviceCreateRenderBundleEncoder",
        CallingConvention = CallingConvention.Cdecl)>]
extern RenderBundleEncoder wgpuDeviceCreateRenderBundleEncoder( Device device, [<In>] RenderBundleEncoderDescriptor& descriptor)

[<DllImport("libwgpu",
        EntryPoint = "wgpuDeviceCreateRenderPipeline",
        CallingConvention = CallingConvention.Cdecl)>]
extern RenderPipeline wgpuDeviceCreateRenderPipeline( Device device, [<In>] RenderPipelineDescriptor& descriptor)

[<DllImport("libwgpu",
        EntryPoint = "wgpuDeviceCreateRenderPipelineAsync",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuDeviceCreateRenderPipelineAsync( Device device, [<In>] RenderPipelineDescriptor& descriptor,  CreateRenderPipelineAsyncCallback callback,  nativeint userdata)

[<DllImport("libwgpu",
        EntryPoint = "wgpuDeviceCreateSampler",
        CallingConvention = CallingConvention.Cdecl)>]
extern Sampler wgpuDeviceCreateSampler( Device device, [<In>] SamplerDescriptor& descriptor)

[<DllImport("libwgpu",
        EntryPoint = "wgpuDeviceCreateShaderModule",
        CallingConvention = CallingConvention.Cdecl)>]
extern ShaderModule wgpuDeviceCreateShaderModule( Device device, [<In>] ShaderModuleDescriptor& descriptor)

[<DllImport("libwgpu",
        EntryPoint = "wgpuDeviceCreateSwapChain",
        CallingConvention = CallingConvention.Cdecl)>]
extern SwapChain wgpuDeviceCreateSwapChain( Device device,  Surface surface, [<In>] SwapChainDescriptor& descriptor)

[<DllImport("libwgpu",
        EntryPoint = "wgpuDeviceCreateTexture",
        CallingConvention = CallingConvention.Cdecl)>]
extern Texture wgpuDeviceCreateTexture( Device device, [<In>] TextureDescriptor& descriptor)

[<DllImport("libwgpu",
        EntryPoint = "wgpuDeviceDestroy",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuDeviceDestroy( Device device)

[<DllImport("libwgpu",
        EntryPoint = "wgpuDeviceEnumerateFeatures",
        CallingConvention = CallingConvention.Cdecl)>]
extern uint64 wgpuDeviceEnumerateFeatures( Device device, [<In ; Out>] FeatureName* features)

[<DllImport("libwgpu",
        EntryPoint = "wgpuDeviceGetLimits",
        CallingConvention = CallingConvention.Cdecl)>]
extern bool wgpuDeviceGetLimits( Device device, [<In ; Out>] SupportedLimits* limits)

[<DllImport("libwgpu",
        EntryPoint = "wgpuDeviceGetQueue",
        CallingConvention = CallingConvention.Cdecl)>]
extern Queue wgpuDeviceGetQueue( Device device)

[<DllImport("libwgpu",
        EntryPoint = "wgpuDeviceHasFeature",
        CallingConvention = CallingConvention.Cdecl)>]
extern bool wgpuDeviceHasFeature( Device device,  FeatureName feature)

[<DllImport("libwgpu",
        EntryPoint = "wgpuDevicePopErrorScope",
        CallingConvention = CallingConvention.Cdecl)>]
extern bool wgpuDevicePopErrorScope( Device device,  ErrorCallback callback,  nativeint userdata)

[<DllImport("libwgpu",
        EntryPoint = "wgpuDevicePushErrorScope",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuDevicePushErrorScope( Device device,  ErrorFilter filter)

[<DllImport("libwgpu",
        EntryPoint = "wgpuDeviceSetDeviceLostCallback",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuDeviceSetDeviceLostCallback( Device device,  DeviceLostCallback callback,  nativeint userdata)

[<DllImport("libwgpu",
        EntryPoint = "wgpuDeviceSetUncapturedErrorCallback",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuDeviceSetUncapturedErrorCallback( Device device,  ErrorCallback callback,  nativeint userdata)

[<DllImport("libwgpu",
        EntryPoint = "wgpuInstanceCreateSurface",
        CallingConvention = CallingConvention.Cdecl)>]
extern Surface wgpuInstanceCreateSurface( Instance instance, [<In>] SurfaceDescriptor& descriptor)

[<DllImport("libwgpu",
        EntryPoint = "wgpuInstanceProcessEvents",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuInstanceProcessEvents( Instance instance)

[<DllImport("libwgpu",
        EntryPoint = "wgpuInstanceRequestAdapter",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuInstanceRequestAdapter( Instance instance, [<In>] RequestAdapterOptions* options,  RequestAdapterCallback callback,  nativeint userdata)

[<DllImport("libwgpu",
        EntryPoint = "wgpuQuerySetDestroy",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuQuerySetDestroy( QuerySet querySet)

[<DllImport("libwgpu",
        EntryPoint = "wgpuQueueOnSubmittedWorkDone",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuQueueOnSubmittedWorkDone( Queue queue,  QueueWorkDoneCallback callback,  nativeint userdata)

[<DllImport("libwgpu",
        EntryPoint = "wgpuQueueSubmit",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuQueueSubmit( Queue queue,  uint32 commandCount, [<In>] CommandBuffer* commands)

[<DllImport("libwgpu",
        EntryPoint = "wgpuQueueWriteBuffer",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuQueueWriteBuffer( Queue queue,  Buffer buffer,  uint64 bufferOffset,  nativeint data,  uint64 size)

[<DllImport("libwgpu",
        EntryPoint = "wgpuQueueWriteTexture",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuQueueWriteTexture( Queue queue, [<In>] ImageCopyTexture* destination,  nativeint data,  uint64 dataSize, [<In>] TextureDataLayout* dataLayout, [<In>] Extent3D* writeSize)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderBundleEncoderDraw",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuRenderBundleEncoderDraw( RenderBundleEncoder renderBundleEncoder,  uint32 vertexCount,  uint32 instanceCount,  uint32 firstVertex,  uint32 firstInstance)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderBundleEncoderDrawIndexed",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuRenderBundleEncoderDrawIndexed( RenderBundleEncoder renderBundleEncoder,  uint32 indexCount,  uint32 instanceCount,  uint32 firstIndex,  int32 baseVertex,  uint32 firstInstance)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderBundleEncoderDrawIndexedIndirect",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuRenderBundleEncoderDrawIndexedIndirect( RenderBundleEncoder renderBundleEncoder,  Buffer indirectBuffer,  uint64 indirectOffset)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderBundleEncoderDrawIndirect",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuRenderBundleEncoderDrawIndirect( RenderBundleEncoder renderBundleEncoder,  Buffer indirectBuffer,  uint64 indirectOffset)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderBundleEncoderFinish",
        CallingConvention = CallingConvention.Cdecl)>]
extern RenderBundle wgpuRenderBundleEncoderFinish( RenderBundleEncoder renderBundleEncoder, [<In>] RenderBundleDescriptor& descriptor)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderBundleEncoderInsertDebugMarker",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuRenderBundleEncoderInsertDebugMarker( RenderBundleEncoder renderBundleEncoder, [<MarshalAs(UnmanagedType.LPStr)>] string markerLabel)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderBundleEncoderPopDebugGroup",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuRenderBundleEncoderPopDebugGroup( RenderBundleEncoder renderBundleEncoder)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderBundleEncoderPushDebugGroup",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuRenderBundleEncoderPushDebugGroup( RenderBundleEncoder renderBundleEncoder, [<MarshalAs(UnmanagedType.LPStr)>] string groupLabel)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderBundleEncoderSetBindGroup",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuRenderBundleEncoderSetBindGroup( RenderBundleEncoder renderBundleEncoder,  uint32 groupIndex,  BindGroup group,  uint32 dynamicOffsetCount, [<In>] uint32* dynamicOffsets)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderBundleEncoderSetIndexBuffer",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuRenderBundleEncoderSetIndexBuffer( RenderBundleEncoder renderBundleEncoder,  Buffer buffer,  IndexFormat format,  uint64 offset,  uint64 size)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderBundleEncoderSetPipeline",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuRenderBundleEncoderSetPipeline( RenderBundleEncoder renderBundleEncoder,  RenderPipeline pipeline)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderBundleEncoderSetVertexBuffer",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuRenderBundleEncoderSetVertexBuffer( RenderBundleEncoder renderBundleEncoder,  uint32 slot,  Buffer buffer,  uint64 offset,  uint64 size)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderPassEncoderBeginOcclusionQuery",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuRenderPassEncoderBeginOcclusionQuery( RenderPassEncoder renderPassEncoder,  uint32 queryIndex)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderPassEncoderBeginPipelineStatisticsQuery",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuRenderPassEncoderBeginPipelineStatisticsQuery( RenderPassEncoder renderPassEncoder,  QuerySet querySet,  uint32 queryIndex)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderPassEncoderDraw",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuRenderPassEncoderDraw( RenderPassEncoder renderPassEncoder,  uint32 vertexCount,  uint32 instanceCount,  uint32 firstVertex,  uint32 firstInstance)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderPassEncoderDrawIndexed",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuRenderPassEncoderDrawIndexed( RenderPassEncoder renderPassEncoder,  uint32 indexCount,  uint32 instanceCount,  uint32 firstIndex,  int32 baseVertex,  uint32 firstInstance)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderPassEncoderDrawIndexedIndirect",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuRenderPassEncoderDrawIndexedIndirect( RenderPassEncoder renderPassEncoder,  Buffer indirectBuffer,  uint64 indirectOffset)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderPassEncoderDrawIndirect",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuRenderPassEncoderDrawIndirect( RenderPassEncoder renderPassEncoder,  Buffer indirectBuffer,  uint64 indirectOffset)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderPassEncoderEnd",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuRenderPassEncoderEnd( RenderPassEncoder renderPassEncoder)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderPassEncoderEndOcclusionQuery",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuRenderPassEncoderEndOcclusionQuery( RenderPassEncoder renderPassEncoder)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderPassEncoderEndPipelineStatisticsQuery",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuRenderPassEncoderEndPipelineStatisticsQuery( RenderPassEncoder renderPassEncoder)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderPassEncoderExecuteBundles",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuRenderPassEncoderExecuteBundles( RenderPassEncoder renderPassEncoder,  uint32 bundlesCount, [<In>] RenderBundle* bundles)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderPassEncoderInsertDebugMarker",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuRenderPassEncoderInsertDebugMarker( RenderPassEncoder renderPassEncoder, [<MarshalAs(UnmanagedType.LPStr)>] string markerLabel)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderPassEncoderPopDebugGroup",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuRenderPassEncoderPopDebugGroup( RenderPassEncoder renderPassEncoder)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderPassEncoderPushDebugGroup",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuRenderPassEncoderPushDebugGroup( RenderPassEncoder renderPassEncoder, [<MarshalAs(UnmanagedType.LPStr)>] string groupLabel)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderPassEncoderSetBindGroup",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuRenderPassEncoderSetBindGroup( RenderPassEncoder renderPassEncoder,  uint32 groupIndex,  BindGroup group,  uint32 dynamicOffsetCount, [<In>] uint32* dynamicOffsets)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderPassEncoderSetBlendConstant",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuRenderPassEncoderSetBlendConstant( RenderPassEncoder renderPassEncoder, [<In>] Color* color)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderPassEncoderSetIndexBuffer",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuRenderPassEncoderSetIndexBuffer( RenderPassEncoder renderPassEncoder,  Buffer buffer,  IndexFormat format,  uint64 offset,  uint64 size)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderPassEncoderSetPipeline",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuRenderPassEncoderSetPipeline( RenderPassEncoder renderPassEncoder,  RenderPipeline pipeline)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderPassEncoderSetScissorRect",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuRenderPassEncoderSetScissorRect( RenderPassEncoder renderPassEncoder,  uint32 x,  uint32 y,  uint32 width,  uint32 height)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderPassEncoderSetStencilReference",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuRenderPassEncoderSetStencilReference( RenderPassEncoder renderPassEncoder,  uint32 reference)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderPassEncoderSetVertexBuffer",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuRenderPassEncoderSetVertexBuffer( RenderPassEncoder renderPassEncoder,  uint32 slot,  Buffer buffer,  uint64 offset,  uint64 size)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderPassEncoderSetViewport",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuRenderPassEncoderSetViewport( RenderPassEncoder renderPassEncoder,  float x,  float y,  float width,  float height,  float minDepth,  float maxDepth)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderPipelineGetBindGroupLayout",
        CallingConvention = CallingConvention.Cdecl)>]
extern BindGroupLayout wgpuRenderPipelineGetBindGroupLayout( RenderPipeline renderPipeline,  uint32 groupIndex)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderPipelineSetLabel",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuRenderPipelineSetLabel( RenderPipeline renderPipeline, [<MarshalAs(UnmanagedType.LPStr)>] string label)

[<DllImport("libwgpu",
        EntryPoint = "wgpuShaderModuleGetCompilationInfo",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuShaderModuleGetCompilationInfo( ShaderModule shaderModule,  CompilationInfoCallback callback,  nativeint userdata)

[<DllImport("libwgpu",
        EntryPoint = "wgpuShaderModuleSetLabel",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuShaderModuleSetLabel( ShaderModule shaderModule, [<MarshalAs(UnmanagedType.LPStr)>] string label)

[<DllImport("libwgpu",
        EntryPoint = "wgpuSurfaceGetPreferredFormat",
        CallingConvention = CallingConvention.Cdecl)>]
extern TextureFormat wgpuSurfaceGetPreferredFormat( Surface surface,  Adapter adapter)

[<DllImport("libwgpu",
        EntryPoint = "wgpuSwapChainGetCurrentTextureView",
        CallingConvention = CallingConvention.Cdecl)>]
extern TextureView wgpuSwapChainGetCurrentTextureView( SwapChain swapChain)

[<DllImport("libwgpu",
        EntryPoint = "wgpuSwapChainPresent",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuSwapChainPresent( SwapChain swapChain)

[<DllImport("libwgpu",
        EntryPoint = "wgpuTextureCreateView",
        CallingConvention = CallingConvention.Cdecl)>]
extern TextureView wgpuTextureCreateView( Texture texture, [<In>] TextureViewDescriptor& descriptor)

[<DllImport("libwgpu",
        EntryPoint = "wgpuTextureDestroy",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuTextureDestroy( Texture texture)

type NativeSType =
    | DeviceExtras = 1610612737
    | AdapterExtras = 1610612738

type NativeFeature =
    | TEXTURE_ADAPTER_SPECIFIC_FORMAT_FEATURES = 268435456

type LogLevel =
    | Off = 0
    | Error = 1
    | Warn = 2
    | Info = 3
    | Debug = 4
    | Trace = 5

///(Unmanaged type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type AdapterExtras =
    struct
        val Chain : ChainedStruct
        val Backend : BackendType
        new (?chain : ChainedStruct, ?backend : BackendType) = {Chain = Option.defaultValue Unchecked.defaultof<ChainedStruct> chain ; Backend = Option.defaultValue Unchecked.defaultof<BackendType> backend}
    end

///(Managed type)
[<StructuralEquality ;
  StructuralComparison ;
  StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi)>]
type DeviceExtras =
    struct
        val Chain : ChainedStruct
        val NativeFeatures : NativeFeature
        [<MarshalAs(UnmanagedType.LPStr)>]
        val Label : string
        [<MarshalAs(UnmanagedType.LPStr)>]
        val TracePath : string
        new (?chain : ChainedStruct, ?nativeFeatures : NativeFeature, ?label : string, ?tracePath : string) = {Chain = Option.defaultValue Unchecked.defaultof<ChainedStruct> chain ; NativeFeatures = Option.defaultValue Unchecked.defaultof<NativeFeature> nativeFeatures ; Label = Option.defaultValue Unchecked.defaultof<string> label ; TracePath = Option.defaultValue Unchecked.defaultof<string> tracePath}
    end

[<UnmanagedFunctionPointer(CallingConvention.Cdecl)>]
type LogCallback
    = delegate of
         level:LogLevel
         * [<MarshalAs(UnmanagedType.LPStr)>] msg:string
          -> unit

[<DllImport("libwgpu",
        EntryPoint = "wgpuDevicePoll",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuDevicePoll( Device device, [<MarshalAs(UnmanagedType.U1)>] bool force_wait)

[<DllImport("libwgpu",
        EntryPoint = "wgpuSetLogCallback",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuSetLogCallback( LogCallback callback)

[<DllImport("libwgpu",
        EntryPoint = "wgpuSetLogLevel",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuSetLogLevel( LogLevel level)

[<DllImport("libwgpu",
        EntryPoint = "wgpuGetVersion",
        CallingConvention = CallingConvention.Cdecl)>]
extern uint32 wgpuGetVersion()

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderPassEncoderSetPushConstants",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuRenderPassEncoderSetPushConstants( RenderPassEncoder encoder,  ShaderStage stages,  uint32 offset,  uint32 sizeBytes,  nativeint data)

[<DllImport("libwgpu",
        EntryPoint = "wgpuBufferDrop",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuBufferDrop( Buffer buffer)

[<DllImport("libwgpu",
        EntryPoint = "wgpuCommandEncoderDrop",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuCommandEncoderDrop( CommandEncoder commandEncoder)

[<DllImport("libwgpu",
        EntryPoint = "wgpuDeviceDrop",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuDeviceDrop( Device device)

[<DllImport("libwgpu",
        EntryPoint = "wgpuQuerySetDrop",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuQuerySetDrop( QuerySet querySet)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderPipelineDrop",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuRenderPipelineDrop( RenderPipeline renderPipeline)

[<DllImport("libwgpu",
        EntryPoint = "wgpuTextureDrop",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuTextureDrop( Texture texture)

[<DllImport("libwgpu",
        EntryPoint = "wgpuTextureViewDrop",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuTextureViewDrop( TextureView textureView)

[<DllImport("libwgpu",
        EntryPoint = "wgpuSamplerDrop",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuSamplerDrop( Sampler sampler)

[<DllImport("libwgpu",
        EntryPoint = "wgpuBindGroupLayoutDrop",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuBindGroupLayoutDrop( BindGroupLayout bindGroupLayout)

[<DllImport("libwgpu",
        EntryPoint = "wgpuPipelineLayoutDrop",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuPipelineLayoutDrop( PipelineLayout pipelineLayout)

[<DllImport("libwgpu",
        EntryPoint = "wgpuBindGroupDrop",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuBindGroupDrop( BindGroup bindGroup)

[<DllImport("libwgpu",
        EntryPoint = "wgpuShaderModuleDrop",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuShaderModuleDrop( ShaderModule shaderModule)

[<DllImport("libwgpu",
        EntryPoint = "wgpuCommandBufferDrop",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuCommandBufferDrop( CommandBuffer commandBuffer)

[<DllImport("libwgpu",
        EntryPoint = "wgpuRenderBundleDrop",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuRenderBundleDrop( RenderBundle renderBundle)

[<DllImport("libwgpu",
        EntryPoint = "wgpuComputePipelineDrop",
        CallingConvention = CallingConvention.Cdecl)>]
extern void wgpuComputePipelineDrop( ComputePipeline computePipeline)
